<#
    MIT License

    Copyright (c) Microsoft Corporation.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE
#>

# Version 22.05.06.2345

[CmdletBinding(DefaultParameterSetName = "Default", SupportsShouldProcess)]
param (
    [Parameter(Mandatory = $false, ParameterSetName = "Default")]
    [bool]
    $StartFresh = $true,

    [Parameter(Mandatory = $false, ParameterSetName = "Default")]
    [switch]
    $SlowTraversal,

    [Parameter(Mandatory = $true, ParameterSetName = "RemoveInvalidPermissions")]
    [switch]
    $RemoveInvalidPermissions,

    [Parameter(Mandatory = $true, ParameterSetName = "SummarizePreviousResults")]
    [Switch]
    $SummarizePreviousResults,

    [Parameter(ParameterSetName = "Default")]
    [Parameter(ParameterSetName = "RemoveInvalidPermissions")]
    [Parameter(ParameterSetName = "SummarizePreviousResults")]
    [string]
    $ResultsFile = (Join-Path $PSScriptRoot "ValidationResults.csv"),

    [Parameter()]
    [switch]
    $SkipVersionCheck,

    [Parameter(Mandatory = $false, ParameterSetName = "Default")]
    [ValidateSet("Dumpsters", "Limits", "Names", "MailEnabled", "Permissions")]
    [string[]]
    $Tests = @("Dumpsters", "Limits", "Names", "MailEnabled", "Permissions")
)




function New-TestResult {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '', Justification = 'No state change.')]
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
        [string]
        $TestName,

        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
        [string]
        $ResultType,

        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
        [ValidateSet("Information", "Warning", "Error")]
        [string]
        $Severity,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [string]
        $FolderIdentity,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [string]
        $FolderEntryId,

        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [string]
        $ResultData
    )

    process {
        [PSCustomObject]@{
            TestName       = $TestName
            ResultType     = $ResultType
            Severity       = $Severity
            FolderIdentity = $FolderIdentity
            FolderEntryId  = $FolderEntryId
            ResultData     = $ResultData
        }
    }
}

function Test-DumpsterMapping {
    [CmdletBinding()]
    [OutputType([System.Object[]])]
    param (
        [Parameter()]
        [PSCustomObject]
        $FolderData
    )

    begin {
        function Test-DumpsterValid {
            [CmdletBinding()]
            [OutputType([bool])]
            param (
                [Parameter()]
                [PSCustomObject]
                $Folder,

                [Parameter()]
                [PSCustomObject]
                $FolderData
            )

            begin {
                $valid = $true
            }

            process {
                $dumpster = $FolderData.NonIpmEntryIdDictionary[$Folder.DumpsterEntryId]

                if ($null -eq $dumpster -or
                    (-not $dumpster.Identity.StartsWith("\NON_IPM_SUBTREE\DUMPSTER_ROOT", "OrdinalIgnoreCase")) -or
                    $dumpster.DumpsterEntryId -ne $Folder.EntryId) {

                    $valid = $false
                }
            }

            end {
                return $valid
            }
        }

        function NewTestDumpsterMappingResult {
            [CmdletBinding()]
            param (
                [Parameter(Position = 0)]
                [object]
                $Folder
            )

            process {
                $params = @{
                    TestName       = "DumpsterMapping"
                    ResultType     = "BadDumpsterMapping"
                    Severity       = "Error"
                    FolderIdentity = $Folder.Identity
                    FolderEntryId  = $Folder.EntryId
                }

                New-TestResult @params
            }
        }

        $startTime = Get-Date
        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Checking dumpster mappings"
            Id       = 2
            ParentId = 1
        }
    }

    process {
        $FolderData.IpmSubtree | ForEach-Object {
            $progressCount++
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                Write-Progress @progressParams -Status $progressCount -PercentComplete ($progressCount * 100 / $FolderData.IpmSubtree.Count)
            }

            if (-not (Test-DumpsterValid $_ $FolderData)) {
                NewTestDumpsterMappingResult $_
            }
        }

        Write-Progress @progressParams -Status "Checking EFORMS dumpster mappings"

        $FolderData.NonIpmSubtree | Where-Object { $_.Identity -like "\NON_IPM_SUBTREE\EFORMS REGISTRY\*" } | ForEach-Object {
            if (-not (Test-DumpsterValid $_ $FolderData)) {
                NewTestDumpsterMappingResult $_
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed

        $params = @{
            TestName   = "DumpsterMapping"
            ResultType = "Duration"
            Severity   = "Information"
            ResultData = ((Get-Date) - $startTime)
        }

        New-TestResult @params
    }
}


function Get-ResultSummary {
    [CmdletBinding()]
    param (
        [string]
        $ResultType = $(throw "ResultType is mandatory"),

        [ValidateSet("Information", "Warning", "Error")]
        [string]
        $Severity = $(throw "Severity is mandatory"),

        [int]
        $Count = $(throw "Count is mandatory"),

        [string]
        $Action = $(throw "Action is mandatory")
    )

    process {
        [PSCustomObject]@{
            ResultType = $ResultType
            Severity   = $Severity
            Count      = $Count
            Action     = $Action
        }
    }
}

function Write-TestDumpsterMappingResult {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object]
        $TestResult
    )

    begin {
        $badDumpsters = New-Object System.Collections.ArrayList
    }

    process {
        if ($TestResult.TestName -eq "DumpsterMapping" -and $TestResult.ResultType -eq "BadDumpsterMapping") {
            $badDumpsters += $TestResult
        }
    }

    end {
        if ($badDumpsters.Count -gt 0) {
            Get-ResultSummary -ResultType $badDumpsters[0].ResultType -Severity $badDumpsters[0].Severity -Count $badDumpsters.Count -Action `
                "Use the -ExcludeDumpsters switch to skip these folders during migration, or delete the folders."
        }
    }
}



function Test-FolderLimit {
    <#
    .SYNOPSIS
        Flags folders that exceed the child count limit, depth limit,
        or item limit.
    #>
    [CmdletBinding()]
    param (
        [Parameter()]
        [PSObject]
        $FolderData
    )

    begin {
        $startTime = Get-Date
        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Checking limits"
            Id       = 2
            ParentId = 1
        }
        $testResultParams = @{
            TestName = "Limit"
            Severity = "Error"
        }
        $folderCountMigrationLimit = 250000
        $aggregateChildItemCounts = @{}
    }

    process {
        # We start from the deepest folders and work upwards so we can calculate the aggregate child
        # counts in one pass
        foreach ($folder in ($FolderData.IpmSubtree | Sort-Object FolderPathDepth -Descending)) {
            $progressCount++
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                Write-Progress @progressParams -Status $progressCount -PercentComplete ($progressCount * 100 / $FolderData.IpmSubtree.Count)
            }

            $stats = $FolderData.StatisticsDictionary[$folder.EntryId]
            [int]$itemCount = $stats.ItemCount
            [Int64]$totalItemSize = $stats.TotalItemSize

            $parent = $FolderData.EntryIdDictionary[$folder.ParentEntryId]
            if ($null -ne $parent) {
                $aggregateChildItemCounts[$parent.EntryId] += $itemCount
            }

            if ($itemCount -lt 1 -and $aggregateChildItemCounts[$folder.EntryId] -lt 1 -and $folder.FolderPathDepth -gt 0) {
                $emptyFolderInformation = @{
                    TestName       = "Limit"
                    Severity       = "Information"
                    ResultType     = "EmptyFolder"
                    FolderIdentity = $folder.Identity.ToString()
                    FolderEntryId  = $folder.EntryId.ToString()
                }
                New-TestResult @emptyFolderInformation
            }

            if ($FolderData.ParentEntryIdCounts[$folder.EntryId] -gt 10000) {
                $testResultParams.ResultType = "ChildCount"
                $testResultParams.FolderIdentity = $folder.Identity.ToString()
                $testResultParams.FolderEntryId = $folder.EntryId.ToString()
                New-TestResult @testResultParams
            }

            if ($folder.FolderPathDepth -gt 299) {
                $testResultParams.ResultType = "FolderPathDepth"
                $testResultParams.FolderIdentity = $folder.Identity.ToString()
                $testResultParams.FolderEntryId = $folder.EntryId.ToString()
                New-TestResult @testResultParams
            }

            if ($itemCount -gt 1000000) {
                $testResultParams.ResultType = "ItemCount"
                $testResultParams.FolderIdentity = $folder.Identity.ToString()
                $testResultParams.FolderEntryId = $folder.EntryId.ToString()
                New-TestResult @testResultParams
            }

            if ($totalItemSize -gt 25000000000) {
                $testResultParams.ResultType = "TotalItemSize"
                $testResultParams.FolderIdentity = $folder.Identity.ToString()
                $testResultParams.FolderEntryId = $folder.EntryId.ToString()
                New-TestResult @testResultParams
            }
        }

        if ($folderData.IpmSubtree.Count -gt $folderCountMigrationLimit) {
            $testResultParams.ResultType = "HierarchyCount"
            $testResultParams.FolderIdentity = ""
            $testResultParams.FolderEntryId = ""
            $testResultParams.ResultData = $folderData.IpmSubtree.Count
            New-TestResult @testResultParams
        } elseif ($folderData.IpmSubtree.Count * 2 -gt $folderCountMigrationLimit) {
            $testResultParams.ResultType = "HierarchyAndDumpsterCount"
            $testResultParams.FolderIdentity = ""
            $testResultParams.FolderEntryId = ""
            $testResultParams.ResultData = $folderData.IpmSubtree.Count
            New-TestResult @testResultParams
        }
    }

    end {
        Write-Progress @progressParams -Completed

        $params = @{
            TestName       = $testResultParams.TestName
            ResultType     = "Duration"
            Severity       = "Information"
            FolderIdentity = ""
            FolderEntryId  = ""
            ResultData     = ((Get-Date) - $startTime)
        }

        New-TestResult @params
    }
}


function Write-TestFolderLimitResult {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object]
        $TestResult
    )

    begin {
        $childCountResults = New-Object System.Collections.ArrayList
        $folderPathDepthResults = New-Object System.Collections.ArrayList
        $itemCountResults = New-Object System.Collections.ArrayList
        $totalItemSizeResults = New-Object System.Collections.ArrayList
        $emptyFolderResults = New-Object System.Collections.ArrayList
        $hierarchyCountResult = $null
        $hierarchyAndDumpsterCountResult = $null
        $folderCountMigrationLimit = 250000
    }

    process {
        if ($TestResult.TestName -eq "Limit") {
            switch ($TestResult.ResultType) {
                "EmptyFolder" { [void]$emptyFolderResults.Add($TestResult) }
                "ChildCount" { [void]$childCountResults.Add($TestResult) }
                "FolderPathDepth" { [void]$folderPathDepthResults.Add($TestResult) }
                "ItemCount" { [void]$itemCountResults.Add($TestResult) }
                "TotalItemSize" { [void]$totalItemSizeResults.Add($TestResult) }
                "HierarchyCount" { $hierarchyCountResult = $TestResult }
                "HierarchyAndDumpsterCount" { $hierarchyAndDumpsterCountResult = $TestResult }
            }
        }
    }

    end {
        if ($childCountResults.Count -gt 0) {
            Get-ResultSummary -ResultType $childCountResults[0].ResultType -Severity $childCountResults[0].Severity -Count $childCountResults.Count -Action (
                "Under each of the listed folders, child folders should be relocated or deleted to reduce " +
                "the number of child folders to 10,000 or less.")
        }

        if ($folderPathDepthResults.Count -gt 0) {
            Get-ResultSummary -ResultType $folderPathDepthResults[0].ResultType -Severity $folderPathDepthResults[0].Severity -Count $folderPathDepthResults.Count -Action (
                "These folders should be relocated to reduce the path depth to 299 or less.")
        }

        if ($itemCountResults.Count -gt 0) {
            Get-ResultSummary -ResultType $itemCountResults[0].ResultType -Severity $itemCountResults[0].Severity -Count $itemCountResults.Count -Action (
                "Items should be deleted from these folders to reduce the item count in each folder to 1 million items or less.")
        }

        if ($totalItemSizeResults.Count -gt 0) {
            Get-ResultSummary -ResultType $totalItemSizeResults[0].ResultType -Severity $totalItemSizeResults[0].Severity -Count $totalItemSizeResults.Count -Action (
                "Items should be deleted from these folders until the folder size is less than 25 GB.")
        }

        if ($null -ne $hierarchyCountResult) {
            Get-ResultSummary -ResultType $hierarchyCountResult.ResultType -Severity $hierarchyCountResult.Severity -Count 1 -Action (
                "There are $($hierarchyCountResult.ResultData) public folders in the hierarchy. This exceeds " +
                "the supported migration limit of $folderCountMigrationLimit for Exchange Online. The number " +
                "of public folders must be reduced prior to migrating to Exchange Online.")
        }

        if ($null -ne $hierarchyAndDumpsterCountResult) {
            Get-ResultSummary -ResultType $hierarchyAndDumpsterCountResult.ResultType -Severity $hierarchyAndDumpsterCountResult.Severity -Count 1 -Action (
                "There are $($hierarchyAndDumpsterCountResult.ResultData) public folders in the hierarchy. Because each of these " +
                "has a dumpster folder, the total number of folders to migrate will be twice as many. " +
                "This exceeds the supported migration limit of $folderCountMigrationLimit for Exchange Online. " +
                "New-MigrationBatch can be run with the -ExcludeDumpsters switch to skip the dumpster " +
                "folders, or public folders may be deleted to reduce the number of folders.")
        }

        if ($emptyFolderResults.Count -gt 0) {
            Get-ResultSummary -ResultType $emptyFolderResults[0].ResultType -Severity $emptyFolderResults[0].Severity -Count $emptyFolderResults.Count -Action (
                "Folders contain no items and have only empty subfolders. " +
                "These will not cause a migration issue, but they may be pruned if desired.")
        }
    }
}



function Test-FolderName {
    [CmdletBinding()]
    param (
        [Parameter()]
        [PSObject]
        $FolderData
    )

    begin {
        $startTime = Get-Date
        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Checking names"
            Id       = 2
            ParentId = 1
        }
        $testResultParams = @{
            TestName   = "FolderName"
            Severity   = "Error"
            ResultType = "SpecialCharacters"
        }
    }

    process {
        $FolderData.IpmSubtree | ForEach-Object {
            $progressCount++
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                Write-Progress @progressParams -Status $progressCount -PercentComplete ($progressCount * 100 / $FolderData.IpmSubtree.Count)
            }

            if ($_.Name -match "@|/|\\") {
                $testResultParams.FolderIdentity = $_.Identity.ToString()
                $testResultParams.FolderEntryId = $_.EntryId.ToString()
                $testResultParams.ResultData = $_.Name
                New-TestResult @testResultParams
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed

        $params = @{
            TestName       = $testResultParams.TestName
            ResultType     = "Duration"
            Severity       = "Information"
            FolderIdentity = ""
            FolderEntryId  = ""
            ResultData     = ((Get-Date) - $startTime)
        }

        New-TestResult @params
    }
}


function Write-TestFolderNameResult {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object]
        $TestResult
    )

    begin {
        $badNames = New-Object System.Collections.ArrayList
    }

    process {
        if ($TestResult.TestName -eq "FolderName" -and $TestResult.ResultType -eq "SpecialCharacters") {
            [void]$badNames.Add($TestResult)
        }
    }

    end {
        if ($badNames.Count -gt 0) {
            Get-ResultSummary -ResultType $badNames[0].ResultType -Severity $badNames[0].Severity -Count $badNames.Count -Action (
                "Folders have characters @, /, or \ in the folder name. " +
                "These folders should be renamed prior to migrating. The following command " +
                "can be used:`n`n" +
                "Import-Csv .\ValidationResults.csv |`n" +
                " ? ResultType -eq SpecialCharacters |`n" +
                " % {`n" +
                "  `$newName = (`$_.ResultData -replace `"@|/|\\`", `" `").Trim()`n" +
                "  Set-PublicFolder `$_.FolderEntryId -Name `$newName`n" +
                " }")
        }
    }
}



function Test-MailEnabledFolder {
    [CmdletBinding()]
    [OutputType([PSCustomObject])]
    param (
        [Parameter()]
        [PSCustomObject]
        $FolderData
    )

    begin {
        function GetCommandToMergeEmailAddresses($publicFolder, $orphanedMailPublicFolder) {
            $linkedMailPublicFolder = Get-PublicFolder $publicFolder.Identity | Get-MailPublicFolder
            $emailAddressesOnGoodObject = @($linkedMailPublicFolder.EmailAddresses | Where-Object { $_.ToString().StartsWith("smtp:", "OrdinalIgnoreCase") } | ForEach-Object { $_.ToString().Substring($_.ToString().IndexOf(':') + 1) })
            $emailAddressesOnBadObject = @($orphanedMailPublicFolder.EmailAddresses | Where-Object { $_.ToString().StartsWith("smtp:", "OrdinalIgnoreCase") } | ForEach-Object { $_.ToString().Substring($_.ToString().IndexOf(':') + 1) })
            $emailAddressesToAdd = $emailAddressesOnBadObject | Where-Object { -not $emailAddressesOnGoodObject.Contains($_) }
            $emailAddressesToAdd = $emailAddressesToAdd | ForEach-Object { "`"" + $_ + "`"" }
            if ($emailAddressesToAdd.Count -gt 0) {
                $emailAddressesToAddString = [string]::Join(",", $emailAddressesToAdd)
                $command = "Get-PublicFolder `"$($publicFolder.Identity)`" | Get-MailPublicFolder | Set-MailPublicFolder -EmailAddresses @{add=$emailAddressesToAddString}"
                return $command
            } else {
                return $null
            }
        }

        function NewTestMailEnabledFolderResult {
            [CmdletBinding()]
            param (
                [Parameter(Position = 0)]
                [string]
                $Identity,

                [Parameter(Position = 1)]
                [string]
                $EntryId,

                [Parameter(Position = 2)]
                [ValidateSet("Duration", "MailEnabledSystemFolder", "MailEnabledWithNoADObject", "MailDisabledWithProxyGuid", "OrphanedMPF", "OrphanedMPFDuplicate", "OrphanedMPFDisconnected")]
                [string]
                $ResultType,

                [Parameter(Position = 3)]
                [string]
                $ResultData
            )

            $params = @{
                TestName       = "MailEnabledFolder"
                ResultType     = $ResultType
                Severity       = "Error"
                FolderIdentity = $Identity
                FolderEntryId  = $EntryId
            }

            if ($null -ne $ResultData) {
                $params.ResultData = $ResultData
            }

            New-TestResult @params
        }

        $startTime = Get-Date
        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Validating mail-enabled public folders"
            Id       = 2
            ParentId = 1
        }
    }

    process {
        $FolderData.NonIpmSubtree | Where-Object { $_.MailEnabled -eq $true } | ForEach-Object { NewTestMailEnabledFolderResult -Identity $_.Identity -EntryId $_.EntryId -ResultType "MailEnabledSystemFolder" }
        $ipmSubtreeMailEnabled = @($FolderData.IpmSubtree | Where-Object { $_.MailEnabled -eq $true })
        $mailDisabledWithProxyGuid = @($FolderData.IpmSubtree | Where-Object { $_.MailEnabled -ne $true -and -not [string]::IsNullOrEmpty($_.MailRecipientGuid) -and [Guid]::Empty -ne $_.MailRecipientGuid } | ForEach-Object { $_.Identity.ToString() })
        $mailDisabledWithProxyGuid | ForEach-Object {
            $params = @{
                Identity   = $_.Identity
                EntryId    = $_.EntryId
                ResultType = "MailDisabledWithProxyGuid"
            }

            NewTestMailEnabledFolderResult @params
        }


        $mailPublicFoldersLinked = New-Object 'System.Collections.Generic.Dictionary[string, object]'
        $progressParams.CurrentOperation = "Checking for missing AD objects"
        $startTimeForThisCheck = Get-Date
        for ($i = 0; $i -lt $ipmSubtreeMailEnabled.Count; $i++) {
            $progressCount++
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                $elapsed = ((Get-Date) - $startTimeForThisCheck)
                $estimatedRemaining = [TimeSpan]::FromTicks($ipmSubtreeMailEnabled.Count / $progressCount * $elapsed.Ticks - $elapsed.Ticks).ToString("hh\:mm\:ss")
                Write-Progress @progressParams -PercentComplete ($i * 100 / $ipmSubtreeMailEnabled.Count) -Status ("$i of $($ipmSubtreeMailEnabled.Count) Estimated time remaining: $estimatedRemaining")
            }
            $result = Get-MailPublicFolder $ipmSubtreeMailEnabled[$i].Identity -ErrorAction SilentlyContinue
            if ($null -eq $result) {
                $params = @{
                    Identity   = $ipmSubtreeMailEnabled[$i].Identity
                    EntryId    = $ipmSubtreeMailEnabled[$i].EntryId
                    ResultType = "MailEnabledWithNoADObject"
                }

                NewTestMailEnabledFolderResult @params
            } else {
                $guidString = $result.Guid.ToString()
                if (-not $mailPublicFoldersLinked.ContainsKey($guidString)) {
                    $mailPublicFoldersLinked.Add($guidString, $result) | Out-Null
                }
            }
        }

        $progressCount = 0
        $progressParams.CurrentOperation = "Getting all MailPublicFolder objects"
        $allMailPublicFolders = @(Get-MailPublicFolder -ResultSize Unlimited | ForEach-Object {
                $progressCount++
                if ($sw.ElapsedMilliseconds -gt 1000) {
                    $sw.Restart()
                    Write-Progress @progressParams -Status "$progressCount"
                }

                $_
            })


        $progressCount = 0
        $progressParams.CurrentOperation = "Checking for orphaned MailPublicFolders"
        $orphanedMailPublicFolders = @($allMailPublicFolders | ForEach-Object {
                $progressCount++
                if ($sw.ElapsedMilliseconds -gt 1000) {
                    $sw.Restart()
                    Write-Progress @progressParams -PercentComplete ($progressCount * 100 / $allMailPublicFolders.Count) -Status ("$progressCount of $($allMailPublicFolders.Count)")
                }

                if (!($mailPublicFoldersLinked.ContainsKey($_.Guid.ToString()))) {
                    $_
                }
            })


        $progressParams.CurrentOperation = "Building EntryId HashSets"
        Write-Progress @progressParams
        $byEntryId = New-Object 'System.Collections.Generic.Dictionary[string, object]'
        $FolderData.IpmSubtree | ForEach-Object { $byEntryId.Add($_.EntryId.ToString(), $_) }
        $byPartialEntryId = New-Object 'System.Collections.Generic.Dictionary[string, object]'
        $FolderData.IpmSubtree | ForEach-Object { $byPartialEntryId.Add($_.EntryId.ToString().Substring(44), $_) }

        $progressParams.CurrentOperation = "Checking for orphans that point to a valid folder"
        for ($i = 0; $i -lt $orphanedMailPublicFolders.Count; $i++) {
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                Write-Progress @progressParams -PercentComplete ($i * 100 / $orphanedMailPublicFolders.Count) -Status ("$i of $($orphanedMailPublicFolders.Count)")
            }

            $thisMPF = $orphanedMailPublicFolders[$i]
            $pf = $null
            if ($null -ne $thisMPF.ExternalEmailAddress -and $thisMPF.ExternalEmailAddress.ToString().StartsWith("expf")) {
                $partialEntryId = $thisMPF.ExternalEmailAddress.ToString().Substring(5).Replace("-", "")
                $partialEntryId += "0000"
                if ($byPartialEntryId.TryGetValue($partialEntryId, [ref]$pf)) {
                    if ($pf.MailEnabled -eq $true) {

                        $command = GetCommandToMergeEmailAddresses $pf $thisMPF

                        $params = @{
                            Identity   = $thisMPF.DistinguishedName.Replace("/", "\/")
                            EntryId    = $pf.EntryId
                            ResultType = "OrphanedMPFDuplicate"
                            ResultData = $command
                        }

                        NewTestMailEnabledFolderResult @params
                    } else {
                        $params = @{
                            Identity   = $thisMPF.DistinguishedName.Replace("/", "\/")
                            EntryId    = $pf.EntryId
                            ResultType = "OrphanedMPFDisconnected"
                        }

                        NewTestMailEnabledFolderResult @params
                    }

                    continue
                }
            }

            if ($null -ne $thisMPF.EntryId -and $byEntryId.TryGetValue($thisMPF.EntryId.ToString(), [ref]$pf)) {
                if ($pf.MailEnabled -eq $true) {

                    $command = GetCommandToMergeEmailAddresses $pf $thisMPF

                    $params = @{
                        Identity   = $thisMPF.DistinguishedName.Replace("/", "\/")
                        EntryId    = $pf.EntryId
                        ResultType = "OrphanedMPFDuplicate"
                    }

                    if ($null -ne $command) {
                        $params.ResultData = $command
                    }

                    NewTestMailEnabledFolderResult @params
                } else {
                    $params = @{
                        Identity   = $thisMPF.DistinguishedName.Replace("/", "\/")
                        EntryId    = $pf.EntryId
                        ResultType = "OrphanedMPFDisconnected"
                    }

                    NewTestMailEnabledFolderResult @params
                }
            } else {
                $params = @{
                    Identity   = $thisMPF.DistinguishedName.Replace("/", "\/")
                    EntryId    = ""
                    ResultType = "OrphanedMPF"
                }

                NewTestMailEnabledFolderResult @params
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed

        $params = @{
            TestName       = "MailEnabledFolder"
            ResultType     = "Duration"
            Severity       = "Information"
            FolderIdentity = ""
            FolderEntryId  = ""
            ResultData     = ((Get-Date) - $startTime)
        }

        New-TestResult @params
    }
}


function Write-TestMailEnabledFolderResult {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object]
        $TestResult
    )

    begin {
        $mailEnabledSystemFolderResults = New-Object System.Collections.ArrayList
        $mailEnabledWithNoADObjectResults = New-Object System.Collections.ArrayList
        $mailDisabledWithProxyGuidResults = New-Object System.Collections.ArrayList
        $orphanedMPFResults = New-Object System.Collections.ArrayList
        $orphanedMPFDuplicateResults = New-Object System.Collections.ArrayList
        $orphanedMPFDisconnectedResults = New-Object System.Collections.ArrayList
    }

    process {
        if ($TestResult.TestName -eq "MailEnabledFolder") {
            switch ($TestResult.ResultType) {
                "MailEnabledSystemFolder" { [void]$mailEnabledSystemFolderResults.Add($TestResult) }
                "MailEnabledWithNoADObject" { [void]$mailEnabledWithNoADObjectResults.Add($TestResult) }
                "MailDisabledWithProxyGuid" { [void]$mailDisabledWithProxyGuidResults.Add($TestResult) }
                "OrphanedMPF" { [void]$orphanedMPFResults.Add($TestResult) }
                "OrphanedMPFDuplicate" { [void]$orphanedMPFDuplicateResults.Add($TestResult) }
                "OrphanedMPFDisconnected" { [void]$orphanedMPFDisconnectedResults.Add($TestResult) }
            }
        }
    }

    end {
        if ($mailEnabledSystemFolderResults.Count -gt 0) {
            Get-ResultSummary -ResultType $mailEnabledSystemFolderResults[0].ResultType -Severity $mailEnabledSystemFolderResults[0].Severity -Count $mailEnabledSystemFolderResults.Count -Action (
                "System folders are mail-enabled. These folders should be mail-disabled. " +
                "After confirming the accuracy of the results, you can mail-disable them with the following command:`n`n" +
                "Import-Csv .\ValidationResults.csv |`n" +
                " ? ResultType -eq MailEnabledSystemFolder |`n" +
                " % { Disable-MailPublicFolder $_.FolderIdentity }")
        }

        if ($mailEnabledWithNoADObjectResults.Count -gt 0) {
            Get-ResultSummary -ResultType $mailEnabledWithNoADObjectResults[0].ResultType -Severity $mailEnabledWithNoADObjectResults[0].Severity -Count $mailEnabledWithNoADObjectResults.Count -Action (
                "Folders are mail-enabled, but have no AD object. These folders should be mail-disabled. " +
                "After confirming the accuracy of the results, you can mail-disable them with the following command:`n`n" +
                "Import-Csv .\ValidationResults.csv | `n" +
                " ? ResultType -eq MailEnabledWithNoADObject |`n" +
                " % { Disable-MailPublicFolder $_.FolderIdentity }")
        }

        if ($mailDisabledWithProxyGuidResults.Count -gt 0) {
            Get-ResultSummary -ResultType $mailDisabledWithProxyGuidResults[0].ResultType -Severity $mailDisabledWithProxyGuidResults[0].Severity -Count $mailDisabledWithProxyGuidResults.Count -Action (
                "Folders are mail-disabled, but have proxy GUID values. These folders should be mail-enabled. " +
                "After confirming the accuracy of the results, you can mail-enable them with the following command:`n`n" +
                "Import-Csv .\ValidationResults.csv |`n" +
                " ? ResultType -eq MailDisabledWithProxyGuid |`n" +
                " % { Enable-MailPublicFolder $_.FolderIdentity }")
        }

        if ($orphanedMPFResults.Count -gt 0) {
            Get-ResultSummary -ResultType $orphanedMPFResults[0].ResultType -Severity $orphanedMPFResults[0].Severity -Count $orphanedMPFResults.Count -Action (
                "Mail public folders are orphaned. They exist in Active Directory " +
                "but are not linked to any public folder. Therefore, they should be deleted. " +
                "After confirming the accuracy of the results, you can delete them manually, " +
                "or use a command like this to delete them all:`n`n" +
                "Import-Csv .\ValidationResults.csv |`n" +
                " ? ResultType -eq OrphanedMPF |`n" +
                " % {`n" +
                "  `$folder = ([ADSI](`"LDAP://`$_`"))`n" +
                "  `$parent = ([ADSI]`"`$(`$folder.Parent)`")`n" +
                "  `$parent.Children.Remove(`$folder)`n" +
                " }")
        }

        if ($orphanedMPFDuplicateResults.Count -gt 0) {
            Get-ResultSummary -ResultType $orphanedMPFDuplicateResults[0].ResultType -Severity $orphanedMPFDuplicateResults[0].Severity -Count $orphanedMPFDuplicateResults.Count -Action (
                "Mail public folders point to public folders that point to a different directory object. " +
                "These should be deleted. Their email addresses may be merged onto the linked object. " +
                "After confirming the accuracy of the results, you can delete them manually, " +
                "or use a command like this:`n`n" +
                "Import-Csv .\ValidationResults.csv |`n" +
                " ? ResultType -eq OrphanedMPFDuplicate |`n" +
                " % {`n" +
                "  `$folder = ([ADSI](`"LDAP://`$(`$_.FolderIdentity)`"))`n" +
                "  `$parent = ([ADSI]`"`$(`$folder.Parent)`")`n" +
                "  `$parent.Children.Remove(`$folder)`n" +
                " }`n`n" +
                "After these objects are deleted, the email addresses can be merged onto the linked objects:`n`n" +
                "Import-Csv .\ValidationResults.csv |`n" +
                " ? ResultType -eq OrphanedMPFDuplicate |`n" +
                " % { Invoke-Expression `$_.ResultData }")
        }

        if ($orphanedMPFDisconnectedResults.Count -gt 0) {
            Get-ResultSummary -ResultType $orphanedMPFDisconnectedResults[0].ResultType -Severity $orphanedMPFDisconnectedResults[0].Severity -Count $orphanedMPFDisconnectedResults.Count -Action (
                "Mail public folders point to public folders that are mail-disabled. " +
                "These require manual intervention. Either the directory object should be deleted, or the folder should be mail-enabled, or both. " +
                "Open the ValidationResults.csv and filter for ResultType of OrphanedMPFDisconnected to identify these folders. " +
                "The FolderIdentity provides the DN of the mail object. The FolderEntryId provides the EntryId of the folder.")
        }
    }
}



function Test-BadPermissionJob {
    [CmdletBinding()]
    param (
        [Parameter(Position = 0)]
        [string]
        $Server,

        [Parameter(Position = 1)]
        [string]
        $Mailbox,

        [Parameter(Position = 2)]
        [PSCustomObject[]]
        $Folders
    )

    begin {
        $WarningPreference = "SilentlyContinue"
        Import-PSSession (New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri "http://$Server/powershell" -Authentication Kerberos) | Out-Null
        $startTime = Get-Date
        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Checking permissions in mailbox $Mailbox"
        }
    }

    process {
        $Folders | ForEach-Object {
            $progressCount++
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                $elapsed = ((Get-Date) - $startTime)
                $estimatedRemaining = [TimeSpan]::FromTicks($Folders.Count / $progressCount * $elapsed.Ticks - $elapsed.Ticks).ToString("hh\:mm\:ss")
                Write-Progress @progressParams -Status "$progressCount / $($Folders.Count) Estimated time remaining: $estimatedRemaining" -PercentComplete ($progressCount * 100 / $Folders.Count)
            }

            $identity = $_.Identity.ToString()
            $entryId = $_.EntryId.ToString()
            Get-PublicFolderClientPermission $entryId | ForEach-Object {
                if (
                    ($_.User.DisplayName -ne "Default") -and
                    ($_.User.DisplayName -ne "Anonymous") -and
                    ($null -eq $_.User.ADRecipient) -and
                    ($_.User.UserType.ToString() -eq "Unknown")
                ) {
                    # We can't use New-TestResult here since we are inside a job
                    [PSCustomObject]@{
                        TestName       = "Permission"
                        ResultType     = "BadPermission"
                        Severity       = "Error"
                        FolderIdentity = $identity
                        FolderEntryId  = $entryId
                        ResultData     = $_.User.DisplayName
                    }
                }
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed
        [PSCustomObject]@{
            TestName       = "Permission"
            ResultType     = "$Mailbox Duration"
            Severity       = "Information"
            FolderIdentity = ""
            FolderEntryId  = ""
            ResultData     = ((Get-Date) - $startTime)
        }
    }
}

function Test-Permission {
    [CmdletBinding()]
    param (
        [Parameter()]
        [PSCustomObject]
        $FolderData
    )

    begin {
        $startTime = Get-Date
    }

    process {
        $folderData.IpmSubtreeByMailbox | ForEach-Object {
            $argumentList = $FolderData.MailboxToServerMap[$_.Name], $_.Name, $_.Group
            $name = $_.Name
            $scriptBlock = ${Function:Test-BadPermissionJob}
            Add-JobQueueJob @{
                ArgumentList = $argumentList
                Name         = "$name Permissions Check"
                ScriptBlock  = $scriptBlock
            }
        }

        Wait-QueuedJob
    }

    end {
        $params = @{
            TestName       = "Permission"
            ResultType     = "Duration"
            Severity       = "Information"
            FolderIdentity = ""
            FolderEntryId  = ""
            ResultData     = ((Get-Date) - $startTime)
        }

        New-TestResult @params
    }
}


function Write-TestPermissionResult {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object]
        $TestResult
    )

    begin {
        $badPermissionResults = New-Object System.Collections.ArrayList
    }

    process {
        if ($TestResult.TestName -eq "Permission" -and $TestResult.ResultType -eq "BadPermission") {
            [void]$badPermissionResults.Add($TestResult)
        }
    }

    end {
        if ($badPermissionResults.Count -gt 0) {
            Get-ResultSummary -ResultType $badPermissionResults[0].ResultType -Severity $badPermissionResults[0].Severity -Count $badPermissionResults.Count -Action (
                "Invalid permissions were found. These can be removed using the RemoveInvalidPermissions switch as follows:`n`n" +
                ".\SourceSideValidations.ps1 -RemoveInvalidPermissions")
        }
    }
}

function Remove-InvalidPermission {
    [CmdletBinding(SupportsShouldProcess)]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object]
        $TestResult
    )

    begin {
        $progressParams = @{
            Activity = "Repairing folder permissions"
        }

        $progressCount = 0
        $entryIdsProcessed = New-Object 'System.Collections.Generic.HashSet[string]'
        $badPermissions = New-Object System.Collections.ArrayList

        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
    }

    process {
        if ($TestResult.TestName -eq "Permission" -and $TestResult.ResultType -eq "BadPermission") {
            [void]$badPermissions.Add($TestResult)
        }
    }

    end {
        foreach ($result in $badPermissions) {
            $progressCount++

            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                Write-Progress @progressParams -Status "$progressCount / $($badPermissions.Count)" -PercentComplete ($progressCount * 100 / $badPermissions.Count) -CurrentOperation $permission.Identity
            }

            if ($entryIdsProcessed.Add($result.FolderEntryId)) {
                $permsOnFolder = Get-PublicFolderClientPermission -Identity $result.FolderEntryId
                foreach ($perm in $permsOnFolder) {
                    if (
                        ($perm.User.DisplayName -ne "Default") -and
                        ($perm.User.DisplayName -ne "Anonymous") -and
                        ($null -eq $perm.User.ADRecipient) -and
                        ($perm.User.UserType -eq "Unknown")
                    ) {
                        if ($PSCmdlet.ShouldProcess("$($result.FolderIdentity)", "Remove $($perm.User.DisplayName)")) {
                            Write-Host "Removing $($perm.User.DisplayName) from folder $($result.FolderIdentity)"
                            $perm | Remove-PublicFolderClientPermission -Confirm:$false
                        }
                    }
                }
            }
        }
    }
}


function Get-IpmSubtree {
    [CmdletBinding()]
    param (
        [Parameter(Position = 0)]
        [string]
        $Server,

        [Parameter(Position = 1)]
        [bool]
        $SlowTraversal = $false
    )

    begin {
        $WarningPreference = "SilentlyContinue"
        $progressCount = 0
        $maxRetries = 10
        $retryDelay = [TimeSpan]::FromMinutes(5)
        $ipmSubtree = New-Object System.Collections.ArrayList
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Retrieving IPM_SUBTREE folders"
        }

        # Only used for slow traversal to save progress in case of failure
        $foldersProcessed = New-Object 'System.Collections.Generic.HashSet[string]'

        # This must be defined in the function scope because this function is runs as a job
        function Get-FoldersRecursive {
            [CmdletBinding()]
            param (
                [Parameter(Position = 0)]
                [object]
                $Folder,

                [Parameter(Position = 1)]
                [object]
                $FoldersProcessed
            )

            $children = Get-PublicFolder $Folder.EntryId -GetChildren -ResultSize Unlimited
            foreach ($child in $children) {
                if (-not $FoldersProcessed.Contains($child.EntryId.ToString())) {
                    if ($child.HasSubfolders) {
                        Get-FoldersRecursive $child $FoldersProcessed
                    }

                    $child
                }
            }
        }
    }

    process {
        $getCommand = { Get-PublicFolder -Recurse -ResultSize Unlimited }

        if ($SlowTraversal) {
            $getCommand = { $top = Get-PublicFolder "\"; Get-FoldersRecursive $top $foldersProcessed; $top }
        }

        $outputResultsScriptBlock = {
            [CmdletBinding()]
            param (
                [Parameter(ValueFromPipeline = $true)]
                [object]
                $Folder
            )

            process {
                $progressCount++

                if ($sw.ElapsedMilliseconds -gt 1000) {
                    $sw.Restart()
                    Write-Progress @progressParams -Status $progressCount
                }

                $result = [PSCustomObject]@{
                    Name              = $Folder.Name
                    Identity          = $Folder.Identity.ToString()
                    EntryId           = $Folder.EntryId.ToString()
                    ParentEntryId     = $Folder.ParentFolder.ToString()
                    DumpsterEntryId   = if ($Folder.DumpsterEntryId) { $Folder.DumpsterEntryId.ToString() } else { $null }
                    FolderSize        = $Folder.FolderSize
                    HasSubfolders     = $Folder.HasSubfolders
                    ContentMailbox    = $Folder.ContentMailboxName
                    MailEnabled       = $Folder.MailEnabled
                    MailRecipientGuid = $Folder.MailRecipientGuid
                }

                [void]$ipmSubtree.Add($result)

                [void]$foldersProcessed.Add($Folder.EntryId.ToString())
            }
        }

        for ($retryCount = 1; $retryCount -le $maxRetries; $retryCount++) {
            try {
                Get-PSSession | Remove-PSSession
                Import-PSSession (New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri "http://$Server/powershell" -Authentication Kerberos) -AllowClobber | Out-Null
                Invoke-Command $getCommand | &$outputResultsScriptBlock
                break
            } catch {
                if (-not $SlowTraversal) {
                    throw
                }

                $sw.Restart()
                while ($sw.ElapsedMilliseconds -lt $retryDelay.TotalMilliseconds) {
                    Write-Progress @progressParams -Status "Retry $retryCount of $maxRetries. Error: $($_.Message)"
                    Start-Sleep -Seconds 5
                    $remainingMilliseconds = $retryDelay.TotalMilliseconds - $sw.ElapsedMilliseconds
                    if ($remainingMilliseconds -lt 0) { $remainingMilliseconds = 0 }
                    Write-Progress @progressParams -Status "Retry $retryCount of $maxRetries. Will retry in $([TimeSpan]::FromMilliseconds($remainingMilliseconds))"
                    Start-Sleep -Seconds 5
                }
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed

        return [PSCustomObject]@{
            IpmSubtree = $ipmSubtree
        }
    }
}

function Get-NonIpmSubtree {
    [CmdletBinding()]
    param (
        [Parameter(Position = 0)]
        [string]
        $Server,

        [Parameter(Position = 1)]
        [bool]
        $SlowTraversal = $false
    )

    begin {
        $WarningPreference = "SilentlyContinue"
        $progressCount = 0
        $maxRetries = 10
        $retryDelay = [timespan]::FromMinutes(5)
        $nonIpmSubtree = New-Object System.Collections.ArrayList
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Retrieving NON_IPM_SUBTREE folders"
        }

        # Only used for slow traversal to save progress in case of failure
        $foldersProcessed = New-Object 'System.Collections.Generic.HashSet[string]'

        # This must be defined in the function scope because this function is runs as a job
        function Get-FoldersRecursive {
            [CmdletBinding()]
            param (
                [Parameter(Position = 0)]
                [object]
                $Folder,

                [Parameter(Position = 1)]
                [object]
                $FoldersProcessed
            )

            $children = Get-PublicFolder $Folder.EntryId -GetChildren -ResultSize Unlimited
            foreach ($child in $children) {
                if (-not $FoldersProcessed.Contains($child.EntryId.ToString())) {
                    if ($child.HasSubfolders) {
                        Get-FoldersRecursive $child $FoldersProcessed
                    }

                    $child
                }
            }
        }
    }

    process {
        $getCommand = { Get-PublicFolder "\non_ipm_subtree" -Recurse -ResultSize Unlimited }

        if ($SlowTraversal) {
            $getCommand = { $top = Get-PublicFolder "\non_ipm_subtree"; Get-FoldersRecursive $top $foldersProcessed; $top }
        }

        $outputResultsScriptBlock = {
            [CmdletBinding()]
            param (
                [Parameter(ValueFromPipeline = $true)]
                [object]
                $Folder
            )

            process {
                $progressCount++
                if ($sw.ElapsedMilliseconds -gt 1000) {
                    $sw.Restart()
                    Write-Progress @progressParams -Status $progressCount
                }

                $result = [PSCustomObject]@{
                    Identity        = $Folder.Identity.ToString()
                    EntryId         = $Folder.EntryId.ToString()
                    DumpsterEntryId = if ($Folder.DumpsterEntryId) { $Folder.DumpsterEntryId.ToString() } else { $null }
                    MailEnabled     = $Folder.MailEnabled
                }

                $null = $nonIpmSubtree.Add($result)

                $null = $foldersProcessed.Add($Folder.EntryId.ToString())
            }
        }

        for ($retryCount = 1; $retryCount -le $maxRetries; $retryCount++) {
            try {
                Get-PSSession | Remove-PSSession
                Import-PSSession (New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri "http://$Server/powershell" -Authentication Kerberos) -AllowClobber | Out-Null
                Invoke-Command $getCommand | &$outputResultsScriptBlock
                break
            } catch {
                if (-not $SlowTraversal) {
                    throw
                }

                $sw.Restart()
                while ($sw.ElapsedMilliseconds -lt $retryDelay.TotalMilliseconds) {
                    Write-Progress @progressParams -Status "Retry $retryCount of $maxRetries. Error: $($_.Message)"
                    Start-Sleep -Seconds 5
                    $remainingMilliseconds = $retryDelay.TotalMilliseconds - $sw.ElapsedMilliseconds
                    if ($remainingMilliseconds -lt 0) { $remainingMilliseconds = 0 }
                    Write-Progress @progressParams -Status "Retry $retryCount of $maxRetries. Will retry in $([TimeSpan]::FromMilliseconds($remainingMilliseconds))"
                    Start-Sleep -Seconds 5
                }
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed

        return [PSCustomObject]@{
            NonIpmSubtree = $nonIpmSubtree
        }
    }
}


function Get-StatisticsJob {
    [CmdletBinding()]
    param (
        [Parameter(Position = 0)]
        [string]
        $Server,

        [Parameter(Position = 1)]
        [string]
        $Mailbox,

        [Parameter(Position = 2)]
        [PSCustomObject[]]
        $Folders
    )

    begin {
        $statistics = New-Object System.Collections.ArrayList
        $errors = New-Object System.Collections.ArrayList
        $permanentFailureOccurred = $false
        $permanentFailures = @(
            "Kerberos",
            "Cannot process argument transformation on parameter 'Identity'",
            "Starting a command on the remote server failed"
        )
        $WarningPreference = "SilentlyContinue"
        $Error.Clear()
        Import-PSSession (New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri "http://$Server/powershell" -Authentication Kerberos) -AllowClobber | Out-Null
        if ($Error.Count -gt 0) {
            $permanentFailureOccurred = $true
            foreach ($err in $Error) {
                $errorReport = @{
                    TestName       = "Get-Statistics"
                    ResultType     = "ImportSessionFailure"
                    Severity       = "Error"
                    FolderIdentity = ""
                    FolderEntryId  = ""
                    ResultData     = $err.ToString()
                }

                [void]$errors.Add($errorReport)
            }
        }

        if (-not $permanentFailureOccurred -and $null -eq (Get-Command Get-PublicFolderStatistics -ErrorAction SilentlyContinue)) {
            $permanentFailureOccurred = $true
            $errorReport = @{
                TestName       = "Get-Statistics"
                ResultType     = "CommandNotFound"
                Severity       = "Error"
                FolderIdentity = ""
                FolderEntryId  = ""
                ResultData     = ""
            }

            [void]$errors.Add($errorReport)
        }

        $startTime = Get-Date
        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Getting public folder statistics"
        }
    }

    process {
        if ($permanentFailureOccurred) {
            return
        }

        $ErrorActionPreference = "Stop" # So our try/catch works
        $statistics = New-Object System.Collections.ArrayList
        foreach ($folder in $Folders) {
            $progressCount++
            if ($sw.ElapsedMilliseconds -gt 1000) {
                $sw.Restart()
                Write-Progress @progressParams -Status $progressCount
            }

            try {
                if ([string]::IsNullOrEmpty($folder.EntryId)) {
                    $folderObject = $folder | Format-List | Out-String
                    $foldersCollection = $Folders | Format-List | Out-String
                    $errorDetails = "$folderObject`n`n$foldersCollection"
                    $errorReport = @{
                        TestName       = "Get-Statistics"
                        ResultType     = "NullEntryId"
                        Severity       = "Error"
                        FolderIdentity = $folder.Identity
                        FolderEntryId  = $folder.EntryId
                        ResultData     = $errorDetails
                    }

                    [void]$errors.Add($errorReport)
                }
                $stats = Get-PublicFolderStatistics $folder.EntryId | Select-Object EntryId, ItemCount, TotalItemSize

                [Int64]$totalItemSize = -1
                if ($stats.TotalItemSize.ToString() -match "\(([\d|,|.]+) bytes\)") {
                    $totalItemSize = [Int64]::Parse($Matches[1], "AllowThousands")
                }

                [void]$statistics.Add([PSCustomObject]@{
                        EntryId       = $stats.EntryId
                        ItemCount     = $stats.ItemCount
                        TotalItemSize = $totalItemSize
                    })
            } catch {
                $errorText = $_.ToString()
                $isPermanentFailure = $null -ne ($permanentFailures | Where-Object { $errorText.Contains($_) })
                if ($isPermanentFailure) {
                    $errorReport = @{
                        TestName       = "Get-Statistics"
                        ResultType     = "JobFailure"
                        Severity       = "Error"
                        FolderIdentity = $folder.Identity
                        FolderEntryId  = $folder.EntryId
                        ResultData     = $errorText
                    }

                    [void]$errors.Add($errorReport)
                    $permanentFailureOccurred = $true
                    break
                } else {
                    $errorReport = @{
                        TestName       = "Get-Statistics"
                        ResultType     = "CouldNotGetStatistics"
                        Severity       = "Error"
                        FolderIdentity = $folder.Identity
                        FolderEntryId  = $folder.EntryId
                        ResultData     = $errorText
                    }

                    [void]$errors.Add($errorReport)
                }
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed
        $duration = ((Get-Date) - $startTime)
        return [PSCustomObject]@{
            Statistics       = $statistics
            Errors           = $errors
            PermanentFailure = $permanentFailureOccurred
            Server           = $Server
            Mailbox          = $Mailbox
            Folders          = $Folders
            Duration         = $duration
        }
    }
}

function Get-Statistics {
    <#
    .SYNOPSIS
        Gets the item count for each folder.
    #>
    [CmdletBinding()]
    param (
        [Parameter(Position = 0)]
        [string]
        $Server,

        [Parameter(Position = 1)]
        [PSCustomObject]
        $FolderData = $null
    )

    begin {
        Write-Verbose "$($MyInvocation.MyCommand) called."

        $progressCount = 0
        $sw = New-Object System.Diagnostics.Stopwatch
        $sw.Start()
        $progressParams = @{
            Activity = "Getting public folder statistics"
        }

        $statistics = New-Object System.Collections.ArrayList
        $errors = New-Object System.Collections.ArrayList
    }

    process {
        if ($null -eq $FolderData) {
            $WarningPreference = "SilentlyContinue"
            Import-PSSession (New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri "http://$Server/powershell" -Authentication Kerberos) | Out-Null
            $statistics = Get-PublicFolderStatistics -ResultSize Unlimited | ForEach-Object {
                $progressCount++
                if ($sw.ElapsedMilliseconds -gt 1000) {
                    $sw.Restart()
                    Write-Progress @progressParams -Status $progressCount
                }

                [Int64]$totalItemSize = -1
                if ($_.TotalItemSize.ToString() -match "\(([\d|,|.]+) bytes\)") {
                    $numberString = $Matches[1] -replace "\D", ""
                    $totalItemSize = [Int64]::Parse($numberString)
                }

                [PSCustomObject]@{
                    EntryId       = $_.EntryId
                    ItemCount     = $_.ItemCount
                    TotalItemSize = $totalItemSize
                }
            }
        } else {
            $batchSize = 10000
            $jobsToCreate = New-Object 'System.Collections.Generic.Dictionary[string, System.Collections.ArrayList]'
            foreach ($group in $folderData.IpmSubtreeByMailbox) {
                # MailboxToServerMap is not populated yet, so we can't use it here
                $server = (Get-Mailbox $group.Name -PublicFolder).ServerName
                [int]$mailboxBatchCount = ($group.Group.Count / $batchSize) + 1
                Write-Verbose "Creating $mailboxBatchCount statistics jobs for $($group.Group.Count) folders in mailbox $($group.Name) on server $server."
                $jobsForThisMailbox = New-Object System.Collections.ArrayList
                for ($i = 0; $i -lt $mailboxBatchCount; $i++) {
                    $batch = $group.Group | Select-Object -First $batchSize -Skip ($batchSize * $i)
                    if ($batch.Count -gt 0) {
                        $argumentList = $server, $group.Name, $batch
                        [void]$jobsForThisMailbox.Add(@{
                                ArgumentList = $argumentList
                                Name         = "Statistics $($group.Name) Job $($i + 1)"
                                ScriptBlock  = ${Function:Get-StatisticsJob}
                            })
                    }
                }

                [void]$jobsToCreate.Add($group.Name, $jobsForThisMailbox)
            }

            # Add the jobs by round-robin among the mailboxes so we don't execute all jobs
            # for one mailbox in parallel unless we have to
            $jobsAddedThisRound = 0
            $index = 0
            do {
                $jobsAddedThisRound = 0
                foreach ($mailboxName in $jobsToCreate.Keys) {
                    $batchesForThisMailbox = $jobsToCreate[$mailboxName]
                    if ($batchesForThisMailbox.Count -gt $index) {
                        $jobParams = $batchesForThisMailbox[$index]
                        Add-JobQueueJob $jobParams
                        $jobsAddedThisRound++
                    }
                }

                $index++
            } while ($jobsAddedThisRound -gt 0)

            $hierarchyMailbox = Get-Mailbox -PublicFolder (Get-OrganizationConfig).RootPublicFolderMailbox.ToString()
            $serverWithHierarchy = $hierarchyMailbox.ServerName
            $retryJobNumber = 1

            Wait-QueuedJob | ForEach-Object {
                $finishedJob = $_
                $statistics.AddRange($finishedJob.Statistics)
                $errors.AddRange($finishedJob.Errors)
                Write-Verbose "Retrieved item counts for $($statistics.Count) folders so far. $($errors.Count) errors encountered."
                if ($finishedJob.PermanentFailure) {
                    # If a permanent failure occurred, re-queue remaining items on the server that has the writable
                    # hierarchy, and hope it works there.
                    Write-Host "Job experienced a permanent failure."
                    if ($finishedJob.Server -eq $serverWithHierarchy) {
                        Write-Host "Permanent failure on root mailbox server is not retryable."
                    } else {
                        $entryIdsProcessed = New-Object 'System.Collections.HashSet[string]'
                        $finishedJob.Statistics | ForEach-Object { [void]$entryIdsProcessed.Add($_.EntryId) }
                        $foldersRemaining = @($finishedJob.Folders | Where-Object { -not $entryIdsProcessed.Contains($_.EntryId) })
                        if ($foldersRemaining.Count -gt 0) {
                            Write-Host "$($foldersRemaining.Count) folders remaining in the failed job. Re-queueing for $serverWithHierarchy."
                            $retryJob = @{
                                ArgumentList = $serverWithHierarchy, $hierarchyMailbox.Name, $foldersRemaining
                                Name         = "Statistics Retry Job $($retryJobNumber++)"
                                ScriptBlock  = ${Function:Get-StatisticsJob}
                            }

                            Add-JobQueueJob $retryJob
                        }
                    }
                }
            }
        }
    }

    end {
        Write-Progress @progressParams -Completed

        return [PSCustomObject]@{
            Statistics = $statistics
            Errors     = $errors
        }
    }
}

function Get-FolderData {
    [CmdletBinding()]
    param (
        [Parameter()]
        [bool]
        $StartFresh = $true,

        [Parameter()]
        [bool]
        $SlowTraversal = $false
    )

    begin {
        Write-Verbose "$($MyInvocation.MyCommand) called."
        $startTime = Get-Date
        $serverName = (Get-Mailbox -PublicFolder (Get-OrganizationConfig).RootPublicFolderMailbox.HierarchyMailboxGuid.ToString()).ServerName
        $folderData = [PSCustomObject]@{
            IpmSubtree              = $null
            IpmSubtreeByMailbox     = $null
            ParentEntryIdCounts     = @{}
            EntryIdDictionary       = @{}
            NonIpmSubtree           = $null
            NonIpmEntryIdDictionary = @{}
            MailboxToServerMap      = @{}
            Statistics              = @()
            StatisticsDictionary    = @{}
            Errors                  = New-Object System.Collections.ArrayList
        }
    }

    process {
        if (-not $StartFresh -and (Test-Path $PSScriptRoot\IpmSubtree.csv)) {
            $folderData.IpmSubtree = Import-Csv $PSScriptRoot\IpmSubtree.csv
        } else {
            Add-JobQueueJob @{
                ArgumentList = $serverName, $SlowTraversal
                Name         = "Get-IpmSubtree"
                ScriptBlock  = ${Function:Get-IpmSubtree}
            }
        }

        if (-not $StartFresh -and (Test-Path $PSScriptRoot\NonIpmSubtree.csv)) {
            $folderData.NonIpmSubtree = Import-Csv $PSScriptRoot\NonIpmSubtree.csv
        } else {
            Add-JobQueueJob @{
                ArgumentList = $serverName, $SlowTraversal
                Name         = "Get-NonIpmSubtree"
                ScriptBlock  = ${Function:Get-NonIpmSubtree}
            }
        }

        # If we're not doing slow traversal, we can get the stats concurrently with the other jobs
        if (-not $SlowTraversal) {
            if (-not $StartFresh -and (Test-Path $PSScriptRoot\Statistics.csv)) {
                $folderData.Statistics = Import-Csv $PSScriptRoot\Statistics.csv
            } else {
                Add-JobQueueJob @{
                    ArgumentList = $serverName
                    Name         = "Get-Statistics"
                    ScriptBlock  = ${Function:Get-Statistics}
                }
            }
        }

        $completedJobs = Wait-QueuedJob

        foreach ($job in $completedJobs) {
            if ($null -ne $job.IpmSubtree) {
                $folderData.IpmSubtree = $job.IpmSubtree
                $folderData.IpmSubtree | Export-Csv $PSScriptRoot\IpmSubtree.csv
            }

            if ($null -ne $job.NonIpmSubtree) {
                $folderData.NonIpmSubtree = $job.NonIpmSubtree
                $folderData.NonIpmSubtree | Export-Csv $PSScriptRoot\NonIpmSubtree.csv
            }

            if ($null -ne $job.Statistics) {
                $folderData.Statistics = $job.Statistics
                $folderData.Statistics | Export-Csv $PSScriptRoot\Statistics.csv
            }
        }

        $folderData.IpmSubtreeByMailbox = $folderData.IpmSubtree | Group-Object ContentMailbox
        $folderData.IpmSubtree | ForEach-Object { $folderData.ParentEntryIdCounts[$_.ParentEntryId] += 1 }
        $folderData.IpmSubtree | ForEach-Object { $folderData.EntryIdDictionary[$_.EntryId] = $_ }
        # We can't count on $folder.Path.Depth being available in remote powershell,
        # so we calculate the depth by walking the parent entry IDs.
        $folderData.IpmSubtree | ForEach-Object {
            $pathDepth = 0
            $parent = $folderData.EntryIdDictionary[$_.ParentEntryId]
            while ($null -ne $parent) {
                $pathDepth++
                $parent = $folderData.EntryIdDictionary[$parent.ParentEntryId]
            }

            Add-Member -InputObject $_ -MemberType NoteProperty -Name FolderPathDepth -Value $pathDepth
        }
        $folderData.NonIpmSubtree | ForEach-Object { $folderData.NonIpmEntryIdDictionary[$_.EntryId] = $_ }

        # If we're doing slow traversal, we have to get the stats after we have the hierarchy
        # grouped by mailbox.
        if ($SlowTraversal) {
            if (-not $StartFresh -and (Test-Path $PSScriptRoot\Statistics.csv)) {
                $folderData.Statistics = Import-Csv $PSScriptRoot\Statistics.csv
            } else {
                Write-Verbose "Starting slow traversal item count."
                $statisticsResult = Get-Statistics $serverName $folderData
                $folderData.Statistics = $statisticsResult.Statistics
                $folderData.Statistics | Export-Csv $PSScriptRoot\Statistics.csv
                foreach ($errorParam in $statisticsResult.Errors) {
                    $errorResult = New-TestResult @errorParam
                    $folderData.Errors.Add($errorResult)
                }
            }
        }

        $folderData.Statistics | ForEach-Object { $folderData.StatisticsDictionary[$_.EntryId] = $_ }
    }

    end {
        Write-Host "Get-FolderData duration $((Get-Date) - $startTime)"
        Write-Host "    IPM_SUBTREE folder count: $($folderData.IpmSubtree.Count)"
        Write-Host "    NON_IPM_SUBTREE folder count: $($folderData.NonIpmSubtree.Count)"

        return $folderData
    }
}

$jobsQueued = New-Object 'System.Collections.Generic.Queue[object]'

function Add-JobQueueJob {
    [CmdletBinding()]
    param (
        [Parameter()]
        [PSCustomObject]
        $JobParameters
    )

    begin {
    }

    process {
        $jobsQueued.Enqueue($JobParameters)
        Write-Host "Added job $($JobParameters.Name) to queue."
    }

    end {
    }
}

function Wait-QueuedJob {
    [CmdletBinding()]
    [OutputType([System.Object[]])]
    param (

    )

    begin {
        $jobsRunning = @()
        $jobQueueMaxConcurrency = 5
    }

    process {
        while ($jobsQueued.Count -gt 0 -or $jobsRunning.Count -gt 0) {
            if ($jobsRunning.Count -lt $jobQueueMaxConcurrency -and $jobsQueued.Count -gt 0) {
                $jobArgs = $jobsQueued.Dequeue()
                $newJob = Start-Job @jobArgs
                $jobsRunning += $newJob
                Write-Host "Started executing job $($jobArgs.Name)."
            }

            $justFinished = @($jobsRunning | Where-Object { $_.State -ne "Running" })
            if ($justFinished.Count -gt 0) {
                foreach ($job in $justFinished) {
                    $result = Receive-Job $job
                    $lastProgress = $job.ChildJobs.Progress | Select-Object -Last 1
                    if ($lastProgress) {
                        Write-Progress -Activity $lastProgress.Activity -ParentId 1 -Id ($job.Id + 1) -Completed
                    }
                    Write-Host $job.Name "job finished."
                    Remove-Job $job -Force
                    $result
                }

                $jobsRunning = @($jobsRunning | Where-Object { -not $justFinished.Contains($_) })
            }

            for ($i = 0; $i -lt $jobQueueMaxConcurrency; $i++) {
                if ($jobsRunning.Count -gt $i) {
                    $lastProgress = $jobsRunning[$i].ChildJobs.Progress | Select-Object -Last 1
                    if ($lastProgress) {
                        Write-Progress -Activity $lastProgress.Activity -Status $lastProgress.StatusDescription -PercentComplete $lastProgress.PercentComplete -ParentId 1 -Id ($jobsRunning[$i].Id + 1)
                    }
                }
            }

            Start-Sleep 1
        }
    }
}

<#
    Determines if the script has an update available. Use the optional
    -AutoUpdate switch to make it update itself. Returns $true if an
    update was downloaded, $false otherwise. The result will always
    be $false if the -AutoUpdate switch is not used.
#>
function Test-ScriptVersion {
    [CmdletBinding()]
    [OutputType([bool])]
    param (
        [Parameter(Mandatory = $false)]
        [switch]
        $AutoUpdate,
        [Parameter(Mandatory = $false)]
        [string]
        $VersionsUrl = "https://github.com/microsoft/CSS-Exchange/releases/latest/download/ScriptVersions.csv"
    )

    function Confirm-ProxyServer {
        [CmdletBinding()]
        [OutputType([bool])]
        param (
            [Parameter(Mandatory = $true)]
            [string]
            $TargetUri
        )

        try {
            $proxyObject = ([System.Net.WebRequest]::GetSystemWebproxy()).GetProxy($TargetUri)
            if ($TargetUri -ne $proxyObject.OriginalString) {
                return $true
            } else {
                return $false
            }
        } catch {
            return $false
        }
    }

    function Confirm-Signature {
        [CmdletBinding()]
        [OutputType([bool])]
        param (
            [Parameter(Mandatory = $true)]
            [string]
            $File
        )

        $IsValid = $false
        $MicrosoftSigningRoot2010 = 'CN=Microsoft Root Certificate Authority 2010, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'
        $MicrosoftSigningRoot2011 = 'CN=Microsoft Root Certificate Authority 2011, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'

        try {
            $sig = Get-AuthenticodeSignature -FilePath $File

            if ($sig.Status -ne 'Valid') {
                Write-Warning "Signature is not trusted by machine as Valid, status: $($sig.Status)."
                throw
            }

            $chain = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Chain
            $chain.ChainPolicy.VerificationFlags = "IgnoreNotTimeValid"

            if (-not $chain.Build($sig.SignerCertificate)) {
                Write-Warning "Signer certificate doesn't chain correctly."
                throw
            }

            if ($chain.ChainElements.Count -le 1) {
                Write-Warning "Certificate Chain shorter than expected."
                throw
            }

            $rootCert = $chain.ChainElements[$chain.ChainElements.Count - 1]

            if ($rootCert.Certificate.Subject -ne $rootCert.Certificate.Issuer) {
                Write-Warning "Top-level certifcate in chain is not a root certificate."
                throw
            }

            if ($rootCert.Certificate.Subject -ne $MicrosoftSigningRoot2010 -and $rootCert.Certificate.Subject -ne $MicrosoftSigningRoot2011) {
                Write-Warning "Unexpected root cert. Expected $MicrosoftSigningRoot2010 or $MicrosoftSigningRoot2011, but found $($rootCert.Certificate.Subject)."
                throw
            }

            Write-Host "File signed by $($sig.SignerCertificate.Subject)"

            $IsValid = $true
        } catch {
            $IsValid = $false
        }

        $IsValid
    }

    $scriptName = $script:MyInvocation.MyCommand.Name
    $scriptPath = [IO.Path]::GetDirectoryName($script:MyInvocation.MyCommand.Path)
    $scriptFullName = (Join-Path $scriptPath $scriptName)

    if ((Get-AuthenticodeSignature -FilePath $scriptFullName).Status -eq "NotSigned") {
        Write-Warning "This script appears to be an unsigned test build. Skipping version check."
        return $false
    }

    $oldName = [IO.Path]::GetFileNameWithoutExtension($scriptName) + ".old"
    $oldFullName = (Join-Path $scriptPath $oldName)

    $tempFullName = (Join-Path $env:TEMP $scriptName)

    $BuildVersion = "22.05.06.2345"
    try {
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        if (Confirm-ProxyServer -TargetUri "https://github.com") {
            $webClient = New-Object System.Net.WebClient
            $webClient.Headers.Add("User-Agent", "PowerShell")
            $webClient.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials
        }
        $versionData = [Text.Encoding]::UTF8.GetString((Invoke-WebRequest $VersionsUrl -UseBasicParsing).Content) | ConvertFrom-Csv
        $latestVersion = ($versionData | Where-Object { $_.File -eq $scriptName }).Version
        if ($null -ne $latestVersion -and $latestVersion -ne $BuildVersion) {
            if ($AutoUpdate) {
                if (Test-Path $tempFullName) {
                    Remove-Item $tempFullName -Force -Confirm:$false -ErrorAction Stop
                }
                Write-Host "AutoUpdate: Downloading update."
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Invoke-WebRequest "https://github.com/microsoft/CSS-Exchange/releases/latest/download/$scriptName" -OutFile $tempFullName -UseBasicParsing
                if (Confirm-Signature -File $tempFullName) {
                    Write-Host "AutoUpdate: Signature validated."
                    if (Test-Path $oldFullName) {
                        Remove-Item $oldFullName -Force -Confirm:$false -ErrorAction Stop
                    }
                    Move-Item $scriptFullName $oldFullName
                    Move-Item $tempFullName $scriptFullName
                    Write-Host "AutoUpdate: Succeeded."
                    return $true
                } else {
                    Write-Warning "AutoUpdate: Signature could not be verified: $tempFullName."
                    Write-Warning "AutoUpdate: Update was not applied."
                }
            } else {
                Write-Warning "$scriptName $BuildVersion is outdated. Please download the latest, version $latestVersion."
            }
        }
    } catch {
        # Work around empty catch block rule. The failure is intentionally silent.
        # For example, the script might be running on a computer with no internet access.
        "Version check failed" | Out-Null
    }

    return $false
}

<#
.SYNOPSIS
    Outputs a table of objects with certain values colorized.
.EXAMPLE
    PS C:\> <example usage>
    Explanation of what the example does
.INPUTS
    Inputs (if any)
.OUTPUTS
    Output (if any)
.NOTES
    General notes
#>
function Out-Columns {
    [CmdletBinding()]
    param (
        [Parameter(ValueFromPipeline = $true)]
        [object[]]
        $InputObject,

        [Parameter(Mandatory = $false, Position = 0)]
        [string[]]
        $Properties,

        [Parameter(Mandatory = $false, Position = 1)]
        [scriptblock[]]
        $ColorizerFunctions = @(),

        [Parameter(Mandatory = $false)]
        [int]
        $IndentSpaces = 0,

        [Parameter(Mandatory = $false)]
        [int]
        $LinesBetweenObjects = 0,

        [Parameter(Mandatory = $false)]
        [ref]
        $StringOutput
    )

    begin {
        function WrapLine {
            param([string]$line, [int]$width)
            if ($line.Length -le $width -and $line.IndexOf("`n") -lt 0) {
                return $line
            }

            $lines = New-Object System.Collections.ArrayList

            $noLF = $line.Replace("`r", "")
            $lineSplit = $noLF.Split("`n")
            foreach ($l in $lineSplit) {
                if ($l.Length -le $width) {
                    [void]$lines.Add($l)
                } else {
                    $split = $l.Split(" ")
                    $sb = New-Object System.Text.StringBuilder
                    for ($i = 0; $i -lt $split.Length; $i++) {
                        if ($sb.Length -eq 0 -and $sb.Length + $split[$i].Length -lt $width) {
                            [void]$sb.Append($split[$i])
                        } elseif ($sb.Length -gt 0 -and $sb.Length + $split[$i].Length + 1 -lt $width) {
                            [void]$sb.Append(" " + $split[$i])
                        } elseif ($sb.Length -gt 0) {
                            [void]$lines.Add($sb.ToString())
                            [void]$sb.Clear()
                            $i--
                        } else {
                            if ($split[$i].Length -le $width) {
                                [void]$lines.Add($split[$i])
                            } else {
                                [void]$lines.Add($split[$i].Substring(0, $width))
                                $split[$i] = $split[$i].Substring($width + 1)
                                $i--
                            }
                        }
                    }

                    if ($sb.Length -gt 0) {
                        [void]$lines.Add($sb.ToString())
                    }
                }
            }

            return $lines
        }

        function GetLineObjects {
            param($obj, $props, $colWidths)
            $linesNeededForThisObject = 1
            $multiLineProps = @{}
            for ($i = 0; $i -lt $props.Length; $i++) {
                $p = $props[$i]
                $val = $obj."$p"

                if ($val -isnot [array]) {
                    $val = WrapLine -line $val -width $colWidths[$i]
                } elseif ($val -is [array]) {
                    $val = $val | Where-Object { $null -ne $_ }
                    $val = $val | ForEach-Object { WrapLine -line $_ -width $colWidths[$i] }
                }

                if ($val -is [array]) {
                    $multiLineProps[$p] = $val
                    if ($val.Length -gt $linesNeededForThisObject) {
                        $linesNeededForThisObject = $val.Length
                    }
                }
            }

            if ($linesNeededForThisObject -eq 1) {
                $obj
            } else {
                for ($i = 0; $i -lt $linesNeededForThisObject; $i++) {
                    $lineProps = @{}
                    foreach ($p in $props) {
                        if ($null -ne $multiLineProps[$p] -and $multiLineProps[$p].Length -gt $i) {
                            $lineProps[$p] = $multiLineProps[$p][$i]
                        } elseif ($i -eq 0) {
                            $lineProps[$p] = $obj."$p"
                        } else {
                            $lineProps[$p] = $null
                        }
                    }

                    [PSCustomObject]$lineProps
                }
            }
        }

        function GetColumnColors {
            param($obj, $props, $funcs)

            $consoleHost = (Get-Host).Name -eq "ConsoleHost"
            $colColors = New-Object string[] $props.Count
            for ($i = 0; $i -lt $props.Count; $i++) {
                if ($consoleHost) {
                    $fgColor = (Get-Host).ui.rawui.ForegroundColor
                } else {
                    $fgColor = "White"
                }
                foreach ($func in $funcs) {
                    $result = $func.Invoke($obj, $props[$i])
                    if (-not [string]::IsNullOrEmpty($result)) {
                        $fgColor = $result
                        break # The first colorizer that takes action wins
                    }
                }

                $colColors[$i] = $fgColor
            }

            $colColors
        }

        function GetColumnWidths {
            param($objects, $props)

            $colWidths = New-Object int[] $props.Count

            # Start with the widths of the property names
            for ($i = 0; $i -lt $props.Count; $i++) {
                $colWidths[$i] = $props[$i].Length
            }

            # Now check the widths of the widest values
            foreach ($thing in $objects) {
                for ($i = 0; $i -lt $props.Count; $i++) {
                    $val = $thing."$($props[$i])"
                    if ($null -ne $val) {
                        $width = 0
                        if ($val -isnot [array]) {
                            $val = $val.ToString().Split("`n")
                        }

                        $width = ($val | ForEach-Object {
                                if ($null -ne $_) { $_.ToString() } else { "" }
                            } | Sort-Object Length -Descending | Select-Object -First 1).Length

                        if ($width -gt $colWidths[$i]) {
                            $colWidths[$i] = $width
                        }
                    }
                }
            }

            # If we're within the window width, we're done
            $totalColumnWidth = $colWidths.Length * $padding + ($colWidths | Measure-Object -Sum).Sum + $IndentSpaces
            $windowWidth = (Get-Host).UI.RawUI.WindowSize.Width
            if ($windowWidth -lt 1 -or $totalColumnWidth -lt $windowWidth) {
                return $colWidths
            }

            # Take size away from one or more columns to make them fit
            while ($totalColumnWidth -ge $windowWidth) {
                $startingTotalWidth = $totalColumnWidth
                $widest = $colWidths | Sort-Object -Descending | Select-Object -First 1
                $newWidest = [Math]::Floor($widest * 0.95)
                for ($i = 0; $i -lt $colWidths.Length; $i++) {
                    if ($colWidths[$i] -eq $widest) {
                        $colWidths[$i] = $newWidest
                        break
                    }
                }

                $totalColumnWidth = $colWidths.Length * $padding + ($colWidths | Measure-Object -Sum).Sum + $IndentSpaces
                if ($totalColumnWidth -ge $startingTotalWidth) {
                    # Somehow we didn't reduce the size at all, so give up
                    break
                }
            }

            return $colWidths
        }

        $objects = New-Object System.Collections.ArrayList
        $padding = 2
        $stb = New-Object System.Text.StringBuilder
    }

    process {
        foreach ($thing in $InputObject) {
            [void]$objects.Add($thing)
        }
    }

    end {
        if ($objects.Count -gt 0) {
            $props = $null

            if ($null -ne $Properties) {
                $props = $Properties
            } else {
                $props = $objects[0].PSObject.Properties.Name
            }

            $colWidths = GetColumnWidths $objects $props

            Write-Host
            [void]$stb.Append([System.Environment]::NewLine)

            Write-Host (" " * $IndentSpaces) -NoNewline
            [void]$stb.Append(" " * $IndentSpaces)

            for ($i = 0; $i -lt $props.Count; $i++) {
                Write-Host ("{0,$(-1 * ($colWidths[$i] + $padding))}" -f $props[$i]) -NoNewline
                [void]$stb.Append("{0,$(-1 * ($colWidths[$i] + $padding))}" -f $props[$i])
            }

            Write-Host
            [void]$stb.Append([System.Environment]::NewLine)

            Write-Host (" " * $IndentSpaces) -NoNewline
            [void]$stb.Append(" " * $IndentSpaces)

            for ($i = 0; $i -lt $props.Count; $i++) {
                Write-Host ("{0,$(-1 * ($colWidths[$i] + $padding))}" -f ("-" * $props[$i].Length)) -NoNewline
                [void]$stb.Append("{0,$(-1 * ($colWidths[$i] + $padding))}" -f ("-" * $props[$i].Length))
            }

            Write-Host
            [void]$stb.Append([System.Environment]::NewLine)

            foreach ($o in $objects) {
                $colColors = GetColumnColors -obj $o -props $props -funcs $ColorizerFunctions
                $lineObjects = @(GetLineObjects -obj $o -props $props -colWidths $colWidths)
                foreach ($lineObj in $lineObjects) {
                    Write-Host (" " * $IndentSpaces) -NoNewline
                    [void]$stb.Append(" " * $IndentSpaces)
                    for ($i = 0; $i -lt $props.Count; $i++) {
                        $val = $o."$($props[$i])"
                        Write-Host ("{0,$(-1 * ($colWidths[$i] + $padding))}" -f $lineObj."$($props[$i])") -NoNewline -ForegroundColor $colColors[$i]
                        [void]$stb.Append("{0,$(-1 * ($colWidths[$i] + $padding))}" -f $lineObj."$($props[$i])")
                    }

                    Write-Host
                    [void]$stb.Append([System.Environment]::NewLine)
                }

                for ($i = 0; $i -lt $LinesBetweenObjects; $i++) {
                    Write-Host
                    [void]$stb.Append([System.Environment]::NewLine)
                }
            }

            Write-Host
            [void]$stb.Append([System.Environment]::NewLine)

            if ($null -ne $StringOutput) {
                $StringOutput.Value = $stb.ToString()
            }
        }
    }
}

try {
    if (-not $SkipVersionCheck) {
        if (Test-ScriptVersion -AutoUpdate) {
            # Update was downloaded, so stop here.
            Write-Host "Script was updated. Please rerun the command."
            return
        }
    }

    $errorColor = "Red"
    $configuredErrorColor = (Get-Host).PrivateData.ErrorForegroundColor
    if ($configuredErrorColor -is [ConsoleColor]) {
        $errorColor = $configuredErrorColor
    }

    $warningColor = "Yellow"
    $configuredWarningColor = (Get-Host).PrivateData.WarningForegroundColor
    if ($configuredWarningColor -is [ConsoleColor]) {
        $warningColor = $configuredWarningColor
    }

    $severityColorizer = {
        param($o, $propName)
        if ($propName -eq "Severity") {
            switch ($o.$propName) {
                "Error" { $errorColor }
                "Warning" { $warningColor }
            }
        }
    }

    if ($SummarizePreviousResults) {
        $results = Import-Csv $ResultsFile
        $summary = New-Object System.Collections.ArrayList
        $summary.AddRange(@($results | Write-TestDumpsterMappingResult))
        $summary.AddRange(@($results | Write-TestFolderLimitResult))
        $summary.AddRange(@($results | Write-TestFolderNameResult))
        $summary.AddRange(@($results | Write-TestMailEnabledFolderResult))
        $summary.AddRange(@($results | Write-TestPermissionResult))
        $summary | Out-Columns -LinesBetweenObjects 1 -ColorizerFunctions $severityColorizer
        return
    }

    if ($RemoveInvalidPermissions) {
        if (-not (Test-Path $ResultsFile)) {
            Write-Error "File not found: $ResultsFile. Please specify -ResultsFile or run without -RemoveInvalidPermissions to generate a results file."
        } else {
            Import-Csv $ResultsFile | Remove-InvalidPermission
        }

        return
    }

    $startTime = Get-Date

    if ($null -eq (Get-Command Set-ADServerSettings -ErrorAction:SilentlyContinue)) {
        Write-Warning "Exchange Server cmdlets are not present in this shell."
        return
    }

    Set-ADServerSettings -ViewEntireForest $true

    $progressParams = @{
        Activity = "Validating public folders"
        Id       = 1
    }

    Write-Progress @progressParams -Status "Step 1 of 6"

    $folderData = Get-FolderData -StartFresh $StartFresh -SlowTraversal $SlowTraversal

    if ($folderData.IpmSubtree.Count -lt 1) {
        return
    }

    $script:anyDatabaseDown = $false
    Get-Mailbox -PublicFolder | ForEach-Object {
        try {
            $db = Get-MailboxDatabase $_.Database -Status
            if ($db.Mounted) {
                $folderData.MailboxToServerMap[$_.DisplayName] = $db.Server
            } else {
                Write-Error "Database $db is not mounted. This database holds PF mailbox $_ and must be mounted."
                $script:anyDatabaseDown = $true
            }
        } catch {
            Write-Error $_
            $script:anyDatabaseDown = $true
        }
    }

    if ($script:anyDatabaseDown) {
        Write-Host "One or more PF mailboxes cannot be reached. Unable to proceed."
        return
    }

    # Now we're ready to do the checks

    if (Test-Path $ResultsFile) {
        $directory = [System.IO.Path]::GetDirectoryName($ResultsFile)
        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($ResultsFile)
        $timeString = (Get-Item $ResultsFile).LastWriteTime.ToString("yyMMdd-HHmm")
        Move-Item -Path $ResultsFile -Destination (Join-Path $directory "$($fileName)-$timeString.csv")
    }

    if ($folderData.Errors.Count -gt 0) {
        $folderData.Errors | Export-Csv $ResultsFile -NoTypeInformation
    }

    if ("Dumpsters" -in $Tests) {
        Write-Progress @progressParams -Status "Step 2 of 6"

        $badDumpsters = Test-DumpsterMapping -FolderData $folderData
        $badDumpsters | Export-Csv $ResultsFile -NoTypeInformation -Append
    }

    if ("Limits" -in $Tests) {
        Write-Progress @progressParams -Status "Step 3 of 6"

        # This test emits results in a weird order, so sort them.
        $limitsExceeded = Test-FolderLimit -FolderData $folderData | Sort-Object FolderIdentity
        $limitsExceeded | Export-Csv $ResultsFile -NoTypeInformation -Append
    }

    if ("Names" -in $Tests) {
        Write-Progress @progressParams -Status "Step 4 of 6"

        $badNames = Test-FolderName -FolderData $folderData
        $badNames | Export-Csv $ResultsFile -NoTypeInformation -Append
    }

    if ("MailEnabled" -in $Tests) {
        Write-Progress @progressParams -Status "Step 5 of 6"

        $badMailEnabled = Test-MailEnabledFolder -FolderData $folderData
        $badMailEnabled | Export-Csv $ResultsFile -NoTypeInformation -Append
    }

    if ("Permissions" -in $Tests) {
        Write-Progress @progressParams -Status "Step 6 of 6"

        $badPermissions = Test-Permission -FolderData $folderData
        $badPermissions | Export-Csv $ResultsFile -NoTypeInformation -Append
    }

    # Output the results

    $results = New-Object System.Collections.ArrayList
    $results.AddRange(@($badDumpsters | Write-TestDumpsterMappingResult))
    $results.AddRange(@($limitsExceeded | Write-TestFolderLimitResult))
    $results.AddRange(@($badNames | Write-TestFolderNameResult))
    $results.AddRange(@($badMailEnabled | Write-TestMailEnabledFolderResult))
    $results.AddRange(@($badPermissions | Write-TestPermissionResult))
    $results | Out-Columns -LinesBetweenObjects 1

    Write-Host
    Write-Host "Validation results were written to file:"
    Write-Host $ResultsFile -ForegroundColor Green

    $private:endTime = Get-Date

    Write-Host
    Write-Host "SourceSideValidations complete. Total duration" ($endTime - $startTime)
} finally {
    Write-Host
    Write-Host "Liked the script? Visit " -NoNewline
    Write-Host "https://aka.ms/SSVFeedback" -ForegroundColor Green -NoNewline
    Write-Host " to rate the script or provide feedback."
    Write-Host
}

# SIG # Begin signature block
# MIInuQYJKoZIhvcNAQcCoIInqjCCJ6YCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCCyfc6/hDSCnh3c
# d0PpQ8CCBL2oK6ZPZfGJHKDt2oP49aCCDYEwggX/MIID56ADAgECAhMzAAACUosz
# qviV8znbAAAAAAJSMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNVBAYTAlVTMRMwEQYD
# VQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMTH01pY3Jvc29mdCBDb2RlIFNpZ25p
# bmcgUENBIDIwMTEwHhcNMjEwOTAyMTgzMjU5WhcNMjIwOTAxMTgzMjU5WjB0MQsw
# CQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9u
# ZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMR4wHAYDVQQDExVNaWNy
# b3NvZnQgQ29ycG9yYXRpb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
# AQDQ5M+Ps/X7BNuv5B/0I6uoDwj0NJOo1KrVQqO7ggRXccklyTrWL4xMShjIou2I
# sbYnF67wXzVAq5Om4oe+LfzSDOzjcb6ms00gBo0OQaqwQ1BijyJ7NvDf80I1fW9O
# L76Kt0Wpc2zrGhzcHdb7upPrvxvSNNUvxK3sgw7YTt31410vpEp8yfBEl/hd8ZzA
# v47DCgJ5j1zm295s1RVZHNp6MoiQFVOECm4AwK2l28i+YER1JO4IplTH44uvzX9o
# RnJHaMvWzZEpozPy4jNO2DDqbcNs4zh7AWMhE1PWFVA+CHI/En5nASvCvLmuR/t8
# q4bc8XR8QIZJQSp+2U6m2ldNAgMBAAGjggF+MIIBejAfBgNVHSUEGDAWBgorBgEE
# AYI3TAgBBggrBgEFBQcDAzAdBgNVHQ4EFgQUNZJaEUGL2Guwt7ZOAu4efEYXedEw
# UAYDVR0RBEkwR6RFMEMxKTAnBgNVBAsTIE1pY3Jvc29mdCBPcGVyYXRpb25zIFB1
# ZXJ0byBSaWNvMRYwFAYDVQQFEw0yMzAwMTIrNDY3NTk3MB8GA1UdIwQYMBaAFEhu
# ZOVQBdOCqhc3NyK1bajKdQKVMFQGA1UdHwRNMEswSaBHoEWGQ2h0dHA6Ly93d3cu
# bWljcm9zb2Z0LmNvbS9wa2lvcHMvY3JsL01pY0NvZFNpZ1BDQTIwMTFfMjAxMS0w
# Ny0wOC5jcmwwYQYIKwYBBQUHAQEEVTBTMFEGCCsGAQUFBzAChkVodHRwOi8vd3d3
# Lm1pY3Jvc29mdC5jb20vcGtpb3BzL2NlcnRzL01pY0NvZFNpZ1BDQTIwMTFfMjAx
# MS0wNy0wOC5jcnQwDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQsFAAOCAgEAFkk3
# uSxkTEBh1NtAl7BivIEsAWdgX1qZ+EdZMYbQKasY6IhSLXRMxF1B3OKdR9K/kccp
# kvNcGl8D7YyYS4mhCUMBR+VLrg3f8PUj38A9V5aiY2/Jok7WZFOAmjPRNNGnyeg7
# l0lTiThFqE+2aOs6+heegqAdelGgNJKRHLWRuhGKuLIw5lkgx9Ky+QvZrn/Ddi8u
# TIgWKp+MGG8xY6PBvvjgt9jQShlnPrZ3UY8Bvwy6rynhXBaV0V0TTL0gEx7eh/K1
# o8Miaru6s/7FyqOLeUS4vTHh9TgBL5DtxCYurXbSBVtL1Fj44+Od/6cmC9mmvrti
# yG709Y3Rd3YdJj2f3GJq7Y7KdWq0QYhatKhBeg4fxjhg0yut2g6aM1mxjNPrE48z
# 6HWCNGu9gMK5ZudldRw4a45Z06Aoktof0CqOyTErvq0YjoE4Xpa0+87T/PVUXNqf
# 7Y+qSU7+9LtLQuMYR4w3cSPjuNusvLf9gBnch5RqM7kaDtYWDgLyB42EfsxeMqwK
# WwA+TVi0HrWRqfSx2olbE56hJcEkMjOSKz3sRuupFCX3UroyYf52L+2iVTrda8XW
# esPG62Mnn3T8AuLfzeJFuAbfOSERx7IFZO92UPoXE1uEjL5skl1yTZB3MubgOA4F
# 8KoRNhviFAEST+nG8c8uIsbZeb08SeYQMqjVEmkwggd6MIIFYqADAgECAgphDpDS
# AAAAAAADMA0GCSqGSIb3DQEBCwUAMIGIMQswCQYDVQQGEwJVUzETMBEGA1UECBMK
# V2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0
# IENvcnBvcmF0aW9uMTIwMAYDVQQDEylNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0
# ZSBBdXRob3JpdHkgMjAxMTAeFw0xMTA3MDgyMDU5MDlaFw0yNjA3MDgyMTA5MDla
# MH4xCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdS
# ZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xKDAmBgNVBAMT
# H01pY3Jvc29mdCBDb2RlIFNpZ25pbmcgUENBIDIwMTEwggIiMA0GCSqGSIb3DQEB
# AQUAA4ICDwAwggIKAoICAQCr8PpyEBwurdhuqoIQTTS68rZYIZ9CGypr6VpQqrgG
# OBoESbp/wwwe3TdrxhLYC/A4wpkGsMg51QEUMULTiQ15ZId+lGAkbK+eSZzpaF7S
# 35tTsgosw6/ZqSuuegmv15ZZymAaBelmdugyUiYSL+erCFDPs0S3XdjELgN1q2jz
# y23zOlyhFvRGuuA4ZKxuZDV4pqBjDy3TQJP4494HDdVceaVJKecNvqATd76UPe/7
# 4ytaEB9NViiienLgEjq3SV7Y7e1DkYPZe7J7hhvZPrGMXeiJT4Qa8qEvWeSQOy2u
# M1jFtz7+MtOzAz2xsq+SOH7SnYAs9U5WkSE1JcM5bmR/U7qcD60ZI4TL9LoDho33
# X/DQUr+MlIe8wCF0JV8YKLbMJyg4JZg5SjbPfLGSrhwjp6lm7GEfauEoSZ1fiOIl
# XdMhSz5SxLVXPyQD8NF6Wy/VI+NwXQ9RRnez+ADhvKwCgl/bwBWzvRvUVUvnOaEP
# 6SNJvBi4RHxF5MHDcnrgcuck379GmcXvwhxX24ON7E1JMKerjt/sW5+v/N2wZuLB
# l4F77dbtS+dJKacTKKanfWeA5opieF+yL4TXV5xcv3coKPHtbcMojyyPQDdPweGF
# RInECUzF1KVDL3SV9274eCBYLBNdYJWaPk8zhNqwiBfenk70lrC8RqBsmNLg1oiM
# CwIDAQABo4IB7TCCAekwEAYJKwYBBAGCNxUBBAMCAQAwHQYDVR0OBBYEFEhuZOVQ
# BdOCqhc3NyK1bajKdQKVMBkGCSsGAQQBgjcUAgQMHgoAUwB1AGIAQwBBMAsGA1Ud
# DwQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFHItOgIxkEO5FAVO
# 4eqnxzHRI4k0MFoGA1UdHwRTMFEwT6BNoEuGSWh0dHA6Ly9jcmwubWljcm9zb2Z0
# LmNvbS9wa2kvY3JsL3Byb2R1Y3RzL01pY1Jvb0NlckF1dDIwMTFfMjAxMV8wM18y
# Mi5jcmwwXgYIKwYBBQUHAQEEUjBQME4GCCsGAQUFBzAChkJodHRwOi8vd3d3Lm1p
# Y3Jvc29mdC5jb20vcGtpL2NlcnRzL01pY1Jvb0NlckF1dDIwMTFfMjAxMV8wM18y
# Mi5jcnQwgZ8GA1UdIASBlzCBlDCBkQYJKwYBBAGCNy4DMIGDMD8GCCsGAQUFBwIB
# FjNodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpb3BzL2RvY3MvcHJpbWFyeWNw
# cy5odG0wQAYIKwYBBQUHAgIwNB4yIB0ATABlAGcAYQBsAF8AcABvAGwAaQBjAHkA
# XwBzAHQAYQB0AGUAbQBlAG4AdAAuIB0wDQYJKoZIhvcNAQELBQADggIBAGfyhqWY
# 4FR5Gi7T2HRnIpsLlhHhY5KZQpZ90nkMkMFlXy4sPvjDctFtg/6+P+gKyju/R6mj
# 82nbY78iNaWXXWWEkH2LRlBV2AySfNIaSxzzPEKLUtCw/WvjPgcuKZvmPRul1LUd
# d5Q54ulkyUQ9eHoj8xN9ppB0g430yyYCRirCihC7pKkFDJvtaPpoLpWgKj8qa1hJ
# Yx8JaW5amJbkg/TAj/NGK978O9C9Ne9uJa7lryft0N3zDq+ZKJeYTQ49C/IIidYf
# wzIY4vDFLc5bnrRJOQrGCsLGra7lstnbFYhRRVg4MnEnGn+x9Cf43iw6IGmYslmJ
# aG5vp7d0w0AFBqYBKig+gj8TTWYLwLNN9eGPfxxvFX1Fp3blQCplo8NdUmKGwx1j
# NpeG39rz+PIWoZon4c2ll9DuXWNB41sHnIc+BncG0QaxdR8UvmFhtfDcxhsEvt9B
# xw4o7t5lL+yX9qFcltgA1qFGvVnzl6UJS0gQmYAf0AApxbGbpT9Fdx41xtKiop96
# eiL6SJUfq/tHI4D1nvi/a7dLl+LrdXga7Oo3mXkYS//WsyNodeav+vyL6wuA6mk7
# r/ww7QRMjt/fdW1jkT3RnVZOT7+AVyKheBEyIXrvQQqxP/uozKRdwaGIm1dxVk5I
# RcBCyZt2WwqASGv9eZ/BvW1taslScxMNelDNMYIZjjCCGYoCAQEwgZUwfjELMAkG
# A1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQx
# HjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEoMCYGA1UEAxMfTWljcm9z
# b2Z0IENvZGUgU2lnbmluZyBQQ0EgMjAxMQITMwAAAlKLM6r4lfM52wAAAAACUjAN
# BglghkgBZQMEAgEFAKCBxjAZBgkqhkiG9w0BCQMxDAYKKwYBBAGCNwIBBDAcBgor
# BgEEAYI3AgELMQ4wDAYKKwYBBAGCNwIBFTAvBgkqhkiG9w0BCQQxIgQgNxKoW+iC
# HGEeLDOcuBFqUf6h+TnAqSC+tk7JAK76g0QwWgYKKwYBBAGCNwIBDDFMMEqgGoAY
# AEMAUwBTACAARQB4AGMAaABhAG4AZwBloSyAKmh0dHBzOi8vZ2l0aHViLmNvbS9t
# aWNyb3NvZnQvQ1NTLUV4Y2hhbmdlIDANBgkqhkiG9w0BAQEFAASCAQCzFTzyRq89
# vbrsTfFZI2nUOppvLpsiArCPGt1iH8WD/ZUPk5Mtndi7Jw3FNnsMSCgWoPo0dgMB
# ukqNtQRJPrG8tbbFthDHTDIDew8ZzAU/RyADzsB7GYe0nb8U93Ays/bAqnSvStw6
# KCHRKrVVb7zttp7CB+E2QQ292Nd7bIJZa2VprgvlI0FE3p/TW97LrwhGNu1wCSPr
# gp7Tx5+7w0VuQ+YsH1q091tTu5f8Np2y6lMGMUz9tnnxt2StcGeuJD4oawKzgBx9
# suY/xZdbvlScE+4+IyhXI7bazV35kk5qiMK9beHSn87kHZl7cy8yzAjjwTomLuU3
# y7E9D9BmFrvPoYIXADCCFvwGCisGAQQBgjcDAwExghbsMIIW6AYJKoZIhvcNAQcC
# oIIW2TCCFtUCAQMxDzANBglghkgBZQMEAgEFADCCAVEGCyqGSIb3DQEJEAEEoIIB
# QASCATwwggE4AgEBBgorBgEEAYRZCgMBMDEwDQYJYIZIAWUDBAIBBQAEIIIToVVZ
# n7aWb2LEd/4Y9Wr485olwiW+PneWr7qsKQYxAgZiadkA4gEYEzIwMjIwNTEzMjIw
# ODAzLjkyOVowBIACAfSggdCkgc0wgcoxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpX
# YXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQg
# Q29ycG9yYXRpb24xJTAjBgNVBAsTHE1pY3Jvc29mdCBBbWVyaWNhIE9wZXJhdGlv
# bnMxJjAkBgNVBAsTHVRoYWxlcyBUU1MgRVNOOjIyNjQtRTMzRS03ODBDMSUwIwYD
# VQQDExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNloIIRVzCCBwwwggT0oAMC
# AQICEzMAAAGYdrOMxdAFoQEAAQAAAZgwDQYJKoZIhvcNAQELBQAwfDELMAkGA1UE
# BhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAc
# BgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0
# IFRpbWUtU3RhbXAgUENBIDIwMTAwHhcNMjExMjAyMTkwNTE1WhcNMjMwMjI4MTkw
# NTE1WjCByjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNV
# BAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjElMCMG
# A1UECxMcTWljcm9zb2Z0IEFtZXJpY2EgT3BlcmF0aW9uczEmMCQGA1UECxMdVGhh
# bGVzIFRTUyBFU046MjI2NC1FMzNFLTc4MEMxJTAjBgNVBAMTHE1pY3Jvc29mdCBU
# aW1lLVN0YW1wIFNlcnZpY2UwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC
# AQDG1JWsVksp8xG4sLMnfxfit3ShI+7G1MfTT+5XvQzuAOe8r5MRAFITTmjFxzoL
# FfmaxLvPVlmDgkDi0rqsOs9Al9jVwYSFVF/wWC2+B76OysiyRjw+NPj5A4cmMhPq
# IdNkRLCE+wtuI/wCaq3/Lf4koDGudIcEYRgMqqToOOUIV4e7EdYb3k9rYPN7Sslw
# sLFSp+Fvm/Qcy5KqfkmMX4S3oJx7HdiQhKbK1C6Zfib+761bmrdPLT6eddlnywls
# 7hCrIIuFtgUbUj6KJIZn1MbYY8hrAM59tvLpeGmFW3GjeBAmvBxAn7o9Lp2nykT1
# w9I0s9ddwpFnjLT2PK74GDSsxFUZG1UtLypi/kZcg9WenPAZpUtPFfO5Mtif8Ja8
# jXXLIP6K+b5LiQV8oIxFSBfgFN7/TL2tSSfQVcvqX1mcSOrx/tsgq3L6YAxI6Pl4
# h1zQrcAmToypEoPYNc/RlSBk6ljmNyNDsX3gtK8p6c7HCWUhF+YjMgfanQmMjUYs
# bjdEsCyL6QAojZ0f6kteN4cV6obFwcUEviYygWbedaT86OGe9LEOxPuhzgFv2Zob
# Vr0J8hl1FVdcZFbfFN/gdjHZ/ncDDqLNWgcoMoEhwwzo7FAObqKaxfB5zCBqYSj4
# 5miNO5g3hP8AgC0eSCHl3rK7JPMr1B+8JTHtwRkSKz/+cwIDAQABo4IBNjCCATIw
# HQYDVR0OBBYEFG6RhHKNpsg3mgons7LR5YHTzeE3MB8GA1UdIwQYMBaAFJ+nFV0A
# XmJdg/Tl0mWnG1M1GelyMF8GA1UdHwRYMFYwVKBSoFCGTmh0dHA6Ly93d3cubWlj
# cm9zb2Z0LmNvbS9wa2lvcHMvY3JsL01pY3Jvc29mdCUyMFRpbWUtU3RhbXAlMjBQ
# Q0ElMjAyMDEwKDEpLmNybDBsBggrBgEFBQcBAQRgMF4wXAYIKwYBBQUHMAKGUGh0
# dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY2VydHMvTWljcm9zb2Z0JTIw
# VGltZS1TdGFtcCUyMFBDQSUyMDIwMTAoMSkuY3J0MAwGA1UdEwEB/wQCMAAwEwYD
# VR0lBAwwCgYIKwYBBQUHAwgwDQYJKoZIhvcNAQELBQADggIBACT6B6F33i/89zXT
# gqQ8L6CYMHx9BiaHOV+wk53JOriCzeaLjYgRyssJhmnnJ/CdHa5qjcSwvRptWpZJ
# PVK5sxhOIjRBPgs/3+ER0vS87IA+aGbf7NF7LZZlxWPOl/yFBg9qZ3tpOGOohQIn
# Qn5zpV23hWopaN4c49jGJHLPAfy9u7+ZSGQuw14CsW/XRLELHT18I60W0uKOBa5P
# m2ViohMovcbpNUCEERqIO9WPwzIwMRRw34/LgjuslHJop+/1Ve/CfyNqweUmwepQ
# HJrd+wTLUlgm4ENbXF6i52jFfYpESwLdAn56o/pj+grsd2LrAEPQRyh49rWvI/qZ
# fOhtT2FWmzFw6IJvZ7CzT1O+Fc0gIDBNqass5QbmkOkKYy9U7nFA6qn3ZZ+MrZMs
# JTj7gxAf0yMkVqwYWZRk4brY9q8JDPmcfNSjRrVfpYyzEVEqemGanmxvDDTzS2wk
# SBa3zcNwOgYhWBTmJdLgyiWJGeqyj1m5bwNgnOw6NzXCiVMzfbztdkqOdTR88LtA
# JGNRjevWjQd5XitGuegSp2mMJglFzRwkncQau1BJsCj/1aDY4oMiO8conkmaWBrY
# e11QCS896/sZwSdnEUJak0qpnBRFB+THRIxIivCKNbxG2QRZ8dh95cOXgo0YvBN5
# a1p+iJ3vNwzneU2AIC7z3rrIbN2fMIIHcTCCBVmgAwIBAgITMwAAABXF52ueAptJ
# mQAAAAAAFTANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgT
# Cldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29m
# dCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNh
# dGUgQXV0aG9yaXR5IDIwMTAwHhcNMjEwOTMwMTgyMjI1WhcNMzAwOTMwMTgzMjI1
# WjB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMH
# UmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQD
# Ex1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDCCAiIwDQYJKoZIhvcNAQEB
# BQADggIPADCCAgoCggIBAOThpkzntHIhC3miy9ckeb0O1YLT/e6cBwfSqWxOdcjK
# NVf2AX9sSuDivbk+F2Az/1xPx2b3lVNxWuJ+Slr+uDZnhUYjDLWNE893MsAQGOhg
# fWpSg0S3po5GawcU88V29YZQ3MFEyHFcUTE3oAo4bo3t1w/YJlN8OWECesSq/XJp
# rx2rrPY2vjUmZNqYO7oaezOtgFt+jBAcnVL+tuhiJdxqD89d9P6OU8/W7IVWTe/d
# vI2k45GPsjksUZzpcGkNyjYtcI4xyDUoveO0hyTD4MmPfrVUj9z6BVWYbWg7mka9
# 7aSueik3rMvrg0XnRm7KMtXAhjBcTyziYrLNueKNiOSWrAFKu75xqRdbZ2De+JKR
# Hh09/SDPc31BmkZ1zcRfNN0Sidb9pSB9fvzZnkXftnIv231fgLrbqn427DZM9itu
# qBJR6L8FA6PRc6ZNN3SUHDSCD/AQ8rdHGO2n6Jl8P0zbr17C89XYcz1DTsEzOUyO
# ArxCaC4Q6oRRRuLRvWoYWmEBc8pnol7XKHYC4jMYctenIPDC+hIK12NvDMk2ZItb
# oKaDIV1fMHSRlJTYuVD5C4lh8zYGNRiER9vcG9H9stQcxWv2XFJRXRLbJbqvUAV6
# bMURHXLvjflSxIUXk8A8FdsaN8cIFRg/eKtFtvUeh17aj54WcmnGrnu3tz5q4i6t
# AgMBAAGjggHdMIIB2TASBgkrBgEEAYI3FQEEBQIDAQABMCMGCSsGAQQBgjcVAgQW
# BBQqp1L+ZMSavoKRPEY1Kc8Q/y8E7jAdBgNVHQ4EFgQUn6cVXQBeYl2D9OXSZacb
# UzUZ6XIwXAYDVR0gBFUwUzBRBgwrBgEEAYI3TIN9AQEwQTA/BggrBgEFBQcCARYz
# aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9Eb2NzL1JlcG9zaXRvcnku
# aHRtMBMGA1UdJQQMMAoGCCsGAQUFBwMIMBkGCSsGAQQBgjcUAgQMHgoAUwB1AGIA
# QwBBMAsGA1UdDwQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNX2
# VsuP6KJcYmjRPZSQW9fOmhjEMFYGA1UdHwRPME0wS6BJoEeGRWh0dHA6Ly9jcmwu
# bWljcm9zb2Z0LmNvbS9wa2kvY3JsL3Byb2R1Y3RzL01pY1Jvb0NlckF1dF8yMDEw
# LTA2LTIzLmNybDBaBggrBgEFBQcBAQROMEwwSgYIKwYBBQUHMAKGPmh0dHA6Ly93
# d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljUm9vQ2VyQXV0XzIwMTAtMDYt
# MjMuY3J0MA0GCSqGSIb3DQEBCwUAA4ICAQCdVX38Kq3hLB9nATEkW+Geckv8qW/q
# XBS2Pk5HZHixBpOXPTEztTnXwnE2P9pkbHzQdTltuw8x5MKP+2zRoZQYIu7pZmc6
# U03dmLq2HnjYNi6cqYJWAAOwBb6J6Gngugnue99qb74py27YP0h1AdkY3m2CDPVt
# I1TkeFN1JFe53Z/zjj3G82jfZfakVqr3lbYoVSfQJL1AoL8ZthISEV09J+BAljis
# 9/kpicO8F7BUhUKz/AyeixmJ5/ALaoHCgRlCGVJ1ijbCHcNhcy4sa3tuPywJeBTp
# kbKpW99Jo3QMvOyRgNI95ko+ZjtPu4b6MhrZlvSP9pEB9s7GdP32THJvEKt1MMU0
# sHrYUP4KWN1APMdUbZ1jdEgssU5HLcEUBHG/ZPkkvnNtyo4JvbMBV0lUZNlz138e
# W0QBjloZkWsNn6Qo3GcZKCS6OEuabvshVGtqRRFHqfG3rsjoiV5PndLQTHa1V1QJ
# sWkBRH58oWFsc/4Ku+xBZj1p/cvBQUl+fpO+y/g75LcVv7TOPqUxUYS8vwLBgqJ7
# Fx0ViY1w/ue10CgaiQuPNtq6TPmb/wrpNPgkNWcr4A245oyZ1uEi6vAnQj0llOZ0
# dFtq0Z4+7X6gMTN9vMvpe784cETRkPHIqzqKOghif9lwY1NNje6CbaUFEMFxBmoQ
# tB1VM1izoXBm8qGCAs4wggI3AgEBMIH4oYHQpIHNMIHKMQswCQYDVQQGEwJVUzET
# MBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMV
# TWljcm9zb2Z0IENvcnBvcmF0aW9uMSUwIwYDVQQLExxNaWNyb3NvZnQgQW1lcmlj
# YSBPcGVyYXRpb25zMSYwJAYDVQQLEx1UaGFsZXMgVFNTIEVTTjoyMjY0LUUzM0Ut
# NzgwQzElMCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3RhbXAgU2VydmljZaIjCgEB
# MAcGBSsOAwIaAxUA8ywe/iF5M8fIU2aT6yQ3vnPpV5OggYMwgYCkfjB8MQswCQYD
# VQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEe
# MBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3Nv
# ZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDANBgkqhkiG9w0BAQUFAAIFAOYoxgwwIhgP
# MjAyMjA1MTMxOTU3MDBaGA8yMDIyMDUxNDE5NTcwMFowdzA9BgorBgEEAYRZCgQB
# MS8wLTAKAgUA5ijGDAIBADAKAgEAAgIBiwIB/zAHAgEAAgIShjAKAgUA5ioXjAIB
# ADA2BgorBgEEAYRZCgQCMSgwJjAMBgorBgEEAYRZCgMCoAowCAIBAAIDB6EgoQow
# CAIBAAIDAYagMA0GCSqGSIb3DQEBBQUAA4GBAHw6+ZXSLllzAcJAqqfIjugdsmhv
# zR+ejKotrG2B9xalaeoU/OZn6XkdGYitEh/Ah3jd7i/7p4et2VhcctzNPQx69O9k
# DKbGoZ5JWZtM16/KTRObeLKXO7twHIjlrLj/eAaDKbFbIt+mDjLhBXIM4dbdMKLE
# fi9hA8NoYkOYsWblMYIEDTCCBAkCAQEwgZMwfDELMAkGA1UEBhMCVVMxEzARBgNV
# BAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jv
# c29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAg
# UENBIDIwMTACEzMAAAGYdrOMxdAFoQEAAQAAAZgwDQYJYIZIAWUDBAIBBQCgggFK
# MBoGCSqGSIb3DQEJAzENBgsqhkiG9w0BCRABBDAvBgkqhkiG9w0BCQQxIgQgSH7n
# 7znVmQOblN8wsp73+UwitmUeOs1mf9mPX+zDFxcwgfoGCyqGSIb3DQEJEAIvMYHq
# MIHnMIHkMIG9BCC/ps4GOTn/9wO1NhHM9Qfe0loB3slkw1FF3r+bh21WxDCBmDCB
# gKR+MHwxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQH
# EwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xJjAkBgNV
# BAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1wIFBDQSAyMDEwAhMzAAABmHazjMXQBaEB
# AAEAAAGYMCIEIIPtb7CVwKVnwwufdV/JAsDH9qHNq5Y9m94TM7AEvEiUMA0GCSqG
# SIb3DQEBCwUABIICAEUd92wzqZ92hv+Fc6PQJ1yHRdgGFts8mwQJfjy3N8bYpqMt
# 2oHhF/m5dlp0SubmkHdEIiAxsiYUPnYv7e7eKY9ZmLek8dRnevwQKExKqrzkCOKH
# 8mAAr9Bjujt2GAq5cl+6x7HRu9ojZwSbFWho03PeNwnjzx3aC6ucnUX8Ks7TNyV7
# imgZvQuap092S0gNdpcEZc7ACBe0rQzdKgoikKF3Orppmp1RzwaeGpn5jBfHywG6
# gTSOo5N7D5HUvTok0V+NykBeEmoA85fbGlghb/ywWE0g+d4NgOCgX1NpzchUAMj8
# euNJZdqd+6kCmAszYGoJqDlZSITzZMsBptpPgFKc3pNxCACdKRydtxKaKTC0C881
# K0PyPvxxXZh5LKWMf2kY7X8F7e28cShRriz45jUEBG6o3jm1DS/dXxqovyf4ml9W
# s5x9IXl5W/MU/zX9VVAWbFe+1O5vL2j2uoXy2RAetxhKdDzq2P0GyqY97kCf0slt
# fZ9iGGpObwUNgcfludBYvl1C91623mQTZ+CtKr/l+9o08ccnr4kWrPKDAqn0mfs+
# /MQUiOWOU5yNHQNTMjOEum3mnUdBdo5SjiTdUB5P5XIwHS7PY2FpegJ9gUrhUaCp
# ZR2qLKRZCI7TuJKpgONDn94T/xexDf8w59G2BSGyisCiRrZ3P7mP0hstQgJL
# SIG # End signature block
